// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(
    clippy::approx_constant,
    clippy::type_complexity,
    clippy::unreadable_literal,
    clippy::upper_case_acronyms
)]
#![cfg_attr(docsrs, feature(doc_cfg))]

use glib_sys as glib;

mod manual;

pub use manual::*;

#[allow(unused_imports)]
use libc::{FILE, intptr_t, off_t, size_t, ssize_t, time_t, uintptr_t};
#[cfg(unix)]
#[allow(unused_imports)]
use libc::{dev_t, gid_t, pid_t, socklen_t, uid_t};
#[allow(unused_imports)]
use std::ffi::{
    c_char, c_double, c_float, c_int, c_long, c_short, c_uchar, c_uint, c_ulong, c_ushort, c_void,
};

#[allow(unused_imports)]
use glib::{GType, gboolean, gconstpointer, gpointer};

// Enums
pub type GUnixPipeEnd = c_int;
pub const G_UNIX_PIPE_END_READ: GUnixPipeEnd = 0;
pub const G_UNIX_PIPE_END_WRITE: GUnixPipeEnd = 1;

// Callbacks
pub type GUnixFDSourceFunc =
    Option<unsafe extern "C" fn(c_int, glib::GIOCondition, gpointer) -> gboolean>;

// Records
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GUnixPipe {
    pub fds: [c_int; 2],
}

impl ::std::fmt::Debug for GUnixPipe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GUnixPipe @ {self:p}"))
            .field("fds", &self.fds)
            .finish()
    }
}

unsafe extern "C" {

    //=========================================================================
    // Other functions
    //=========================================================================
    #[cfg(feature = "v2_80")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_80")))]
    pub fn g_closefrom(lowfd: c_int) -> c_int;
    pub fn g_unix_error_quark() -> glib::GQuark;
    pub fn g_unix_fd_add(
        fd: c_int,
        condition: glib::GIOCondition,
        function: GUnixFDSourceFunc,
        user_data: gpointer,
    ) -> c_uint;
    pub fn g_unix_fd_add_full(
        priority: c_int,
        fd: c_int,
        condition: glib::GIOCondition,
        function: GUnixFDSourceFunc,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    ) -> c_uint;
    #[cfg(feature = "v2_88")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_88")))]
    pub fn g_unix_fd_query_path(fd: c_int, error: *mut *mut glib::GError) -> *mut c_char;
    pub fn g_unix_fd_source_new(fd: c_int, condition: glib::GIOCondition) -> *mut glib::GSource;
    #[cfg(feature = "v2_80")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_80")))]
    pub fn g_fdwalk_set_cloexec(lowfd: c_int) -> c_int;
    #[cfg(feature = "v2_64")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_64")))]
    pub fn g_unix_get_passwd_entry(
        user_name: *const c_char,
        error: *mut *mut glib::GError,
    ) -> *mut passwd;
    pub fn g_unix_set_fd_nonblocking(
        fd: c_int,
        nonblock: gboolean,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn g_unix_signal_add(
        signum: c_int,
        handler: glib::GSourceFunc,
        user_data: gpointer,
    ) -> c_uint;
    pub fn g_unix_signal_add_full(
        priority: c_int,
        signum: c_int,
        handler: glib::GSourceFunc,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    ) -> c_uint;
    pub fn g_unix_signal_source_new(signum: c_int) -> *mut glib::GSource;

}
