// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use std::fmt;
use std::mem;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkAlign")]
pub enum Align {
    #[doc(alias = "GTK_ALIGN_FILL")]
    Fill,
    #[doc(alias = "GTK_ALIGN_START")]
    Start,
    #[doc(alias = "GTK_ALIGN_END")]
    End,
    #[doc(alias = "GTK_ALIGN_CENTER")]
    Center,
    #[doc(alias = "GTK_ALIGN_BASELINE")]
    Baseline,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Align {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Align::{}",
            match *self {
                Align::Fill => "Fill",
                Align::Start => "Start",
                Align::End => "End",
                Align::Center => "Center",
                Align::Baseline => "Baseline",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Align {
    type GlibType = ffi::GtkAlign;

    fn to_glib(self) -> ffi::GtkAlign {
        match self {
            Align::Fill => ffi::GTK_ALIGN_FILL,
            Align::Start => ffi::GTK_ALIGN_START,
            Align::End => ffi::GTK_ALIGN_END,
            Align::Center => ffi::GTK_ALIGN_CENTER,
            Align::Baseline => ffi::GTK_ALIGN_BASELINE,
            Align::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAlign> for Align {
    unsafe fn from_glib(value: ffi::GtkAlign) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Align::Fill,
            1 => Align::Start,
            2 => Align::End,
            3 => Align::Center,
            4 => Align::Baseline,
            value => Align::__Unknown(value),
        }
    }
}

impl StaticType for Align {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_align_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Align {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Align {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Align {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkArrowType")]
pub enum ArrowType {
    #[doc(alias = "GTK_ARROW_UP")]
    Up,
    #[doc(alias = "GTK_ARROW_DOWN")]
    Down,
    #[doc(alias = "GTK_ARROW_LEFT")]
    Left,
    #[doc(alias = "GTK_ARROW_RIGHT")]
    Right,
    #[doc(alias = "GTK_ARROW_NONE")]
    None,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ArrowType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ArrowType::{}",
            match *self {
                ArrowType::Up => "Up",
                ArrowType::Down => "Down",
                ArrowType::Left => "Left",
                ArrowType::Right => "Right",
                ArrowType::None => "None",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ArrowType {
    type GlibType = ffi::GtkArrowType;

    fn to_glib(self) -> ffi::GtkArrowType {
        match self {
            ArrowType::Up => ffi::GTK_ARROW_UP,
            ArrowType::Down => ffi::GTK_ARROW_DOWN,
            ArrowType::Left => ffi::GTK_ARROW_LEFT,
            ArrowType::Right => ffi::GTK_ARROW_RIGHT,
            ArrowType::None => ffi::GTK_ARROW_NONE,
            ArrowType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkArrowType> for ArrowType {
    unsafe fn from_glib(value: ffi::GtkArrowType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ArrowType::Up,
            1 => ArrowType::Down,
            2 => ArrowType::Left,
            3 => ArrowType::Right,
            4 => ArrowType::None,
            value => ArrowType::__Unknown(value),
        }
    }
}

impl StaticType for ArrowType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_arrow_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ArrowType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ArrowType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ArrowType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkAssistantPageType")]
pub enum AssistantPageType {
    #[doc(alias = "GTK_ASSISTANT_PAGE_CONTENT")]
    Content,
    #[doc(alias = "GTK_ASSISTANT_PAGE_INTRO")]
    Intro,
    #[doc(alias = "GTK_ASSISTANT_PAGE_CONFIRM")]
    Confirm,
    #[doc(alias = "GTK_ASSISTANT_PAGE_SUMMARY")]
    Summary,
    #[doc(alias = "GTK_ASSISTANT_PAGE_PROGRESS")]
    Progress,
    #[doc(alias = "GTK_ASSISTANT_PAGE_CUSTOM")]
    Custom,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AssistantPageType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AssistantPageType::{}",
            match *self {
                AssistantPageType::Content => "Content",
                AssistantPageType::Intro => "Intro",
                AssistantPageType::Confirm => "Confirm",
                AssistantPageType::Summary => "Summary",
                AssistantPageType::Progress => "Progress",
                AssistantPageType::Custom => "Custom",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for AssistantPageType {
    type GlibType = ffi::GtkAssistantPageType;

    fn to_glib(self) -> ffi::GtkAssistantPageType {
        match self {
            AssistantPageType::Content => ffi::GTK_ASSISTANT_PAGE_CONTENT,
            AssistantPageType::Intro => ffi::GTK_ASSISTANT_PAGE_INTRO,
            AssistantPageType::Confirm => ffi::GTK_ASSISTANT_PAGE_CONFIRM,
            AssistantPageType::Summary => ffi::GTK_ASSISTANT_PAGE_SUMMARY,
            AssistantPageType::Progress => ffi::GTK_ASSISTANT_PAGE_PROGRESS,
            AssistantPageType::Custom => ffi::GTK_ASSISTANT_PAGE_CUSTOM,
            AssistantPageType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAssistantPageType> for AssistantPageType {
    unsafe fn from_glib(value: ffi::GtkAssistantPageType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => AssistantPageType::Content,
            1 => AssistantPageType::Intro,
            2 => AssistantPageType::Confirm,
            3 => AssistantPageType::Summary,
            4 => AssistantPageType::Progress,
            5 => AssistantPageType::Custom,
            value => AssistantPageType::__Unknown(value),
        }
    }
}

impl StaticType for AssistantPageType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_assistant_page_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AssistantPageType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for AssistantPageType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for AssistantPageType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkBaselinePosition")]
pub enum BaselinePosition {
    #[doc(alias = "GTK_BASELINE_POSITION_TOP")]
    Top,
    #[doc(alias = "GTK_BASELINE_POSITION_CENTER")]
    Center,
    #[doc(alias = "GTK_BASELINE_POSITION_BOTTOM")]
    Bottom,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for BaselinePosition {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "BaselinePosition::{}",
            match *self {
                BaselinePosition::Top => "Top",
                BaselinePosition::Center => "Center",
                BaselinePosition::Bottom => "Bottom",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for BaselinePosition {
    type GlibType = ffi::GtkBaselinePosition;

    fn to_glib(self) -> ffi::GtkBaselinePosition {
        match self {
            BaselinePosition::Top => ffi::GTK_BASELINE_POSITION_TOP,
            BaselinePosition::Center => ffi::GTK_BASELINE_POSITION_CENTER,
            BaselinePosition::Bottom => ffi::GTK_BASELINE_POSITION_BOTTOM,
            BaselinePosition::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkBaselinePosition> for BaselinePosition {
    unsafe fn from_glib(value: ffi::GtkBaselinePosition) -> Self {
        skip_assert_initialized!();
        match value {
            0 => BaselinePosition::Top,
            1 => BaselinePosition::Center,
            2 => BaselinePosition::Bottom,
            value => BaselinePosition::__Unknown(value),
        }
    }
}

impl StaticType for BaselinePosition {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_baseline_position_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for BaselinePosition {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for BaselinePosition {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for BaselinePosition {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkBorderStyle")]
pub enum BorderStyle {
    #[doc(alias = "GTK_BORDER_STYLE_NONE")]
    None,
    #[doc(alias = "GTK_BORDER_STYLE_SOLID")]
    Solid,
    #[doc(alias = "GTK_BORDER_STYLE_INSET")]
    Inset,
    #[doc(alias = "GTK_BORDER_STYLE_OUTSET")]
    Outset,
    #[doc(alias = "GTK_BORDER_STYLE_HIDDEN")]
    Hidden,
    #[doc(alias = "GTK_BORDER_STYLE_DOTTED")]
    Dotted,
    #[doc(alias = "GTK_BORDER_STYLE_DASHED")]
    Dashed,
    #[doc(alias = "GTK_BORDER_STYLE_DOUBLE")]
    Double,
    #[doc(alias = "GTK_BORDER_STYLE_GROOVE")]
    Groove,
    #[doc(alias = "GTK_BORDER_STYLE_RIDGE")]
    Ridge,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for BorderStyle {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "BorderStyle::{}",
            match *self {
                BorderStyle::None => "None",
                BorderStyle::Solid => "Solid",
                BorderStyle::Inset => "Inset",
                BorderStyle::Outset => "Outset",
                BorderStyle::Hidden => "Hidden",
                BorderStyle::Dotted => "Dotted",
                BorderStyle::Dashed => "Dashed",
                BorderStyle::Double => "Double",
                BorderStyle::Groove => "Groove",
                BorderStyle::Ridge => "Ridge",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for BorderStyle {
    type GlibType = ffi::GtkBorderStyle;

    fn to_glib(self) -> ffi::GtkBorderStyle {
        match self {
            BorderStyle::None => ffi::GTK_BORDER_STYLE_NONE,
            BorderStyle::Solid => ffi::GTK_BORDER_STYLE_SOLID,
            BorderStyle::Inset => ffi::GTK_BORDER_STYLE_INSET,
            BorderStyle::Outset => ffi::GTK_BORDER_STYLE_OUTSET,
            BorderStyle::Hidden => ffi::GTK_BORDER_STYLE_HIDDEN,
            BorderStyle::Dotted => ffi::GTK_BORDER_STYLE_DOTTED,
            BorderStyle::Dashed => ffi::GTK_BORDER_STYLE_DASHED,
            BorderStyle::Double => ffi::GTK_BORDER_STYLE_DOUBLE,
            BorderStyle::Groove => ffi::GTK_BORDER_STYLE_GROOVE,
            BorderStyle::Ridge => ffi::GTK_BORDER_STYLE_RIDGE,
            BorderStyle::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkBorderStyle> for BorderStyle {
    unsafe fn from_glib(value: ffi::GtkBorderStyle) -> Self {
        skip_assert_initialized!();
        match value {
            0 => BorderStyle::None,
            1 => BorderStyle::Solid,
            2 => BorderStyle::Inset,
            3 => BorderStyle::Outset,
            4 => BorderStyle::Hidden,
            5 => BorderStyle::Dotted,
            6 => BorderStyle::Dashed,
            7 => BorderStyle::Double,
            8 => BorderStyle::Groove,
            9 => BorderStyle::Ridge,
            value => BorderStyle::__Unknown(value),
        }
    }
}

impl StaticType for BorderStyle {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_border_style_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for BorderStyle {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for BorderStyle {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for BorderStyle {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkBuilderError")]
pub enum BuilderError {
    #[doc(alias = "GTK_BUILDER_ERROR_INVALID_TYPE_FUNCTION")]
    InvalidTypeFunction,
    #[doc(alias = "GTK_BUILDER_ERROR_UNHANDLED_TAG")]
    UnhandledTag,
    #[doc(alias = "GTK_BUILDER_ERROR_MISSING_ATTRIBUTE")]
    MissingAttribute,
    #[doc(alias = "GTK_BUILDER_ERROR_INVALID_ATTRIBUTE")]
    InvalidAttribute,
    #[doc(alias = "GTK_BUILDER_ERROR_INVALID_TAG")]
    InvalidTag,
    #[doc(alias = "GTK_BUILDER_ERROR_MISSING_PROPERTY_VALUE")]
    MissingPropertyValue,
    #[doc(alias = "GTK_BUILDER_ERROR_INVALID_VALUE")]
    InvalidValue,
    #[doc(alias = "GTK_BUILDER_ERROR_VERSION_MISMATCH")]
    VersionMismatch,
    #[doc(alias = "GTK_BUILDER_ERROR_DUPLICATE_ID")]
    DuplicateId,
    #[doc(alias = "GTK_BUILDER_ERROR_OBJECT_TYPE_REFUSED")]
    ObjectTypeRefused,
    #[doc(alias = "GTK_BUILDER_ERROR_TEMPLATE_MISMATCH")]
    TemplateMismatch,
    #[doc(alias = "GTK_BUILDER_ERROR_INVALID_PROPERTY")]
    InvalidProperty,
    #[doc(alias = "GTK_BUILDER_ERROR_INVALID_SIGNAL")]
    InvalidSignal,
    #[doc(alias = "GTK_BUILDER_ERROR_INVALID_ID")]
    InvalidId,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for BuilderError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "BuilderError::{}",
            match *self {
                BuilderError::InvalidTypeFunction => "InvalidTypeFunction",
                BuilderError::UnhandledTag => "UnhandledTag",
                BuilderError::MissingAttribute => "MissingAttribute",
                BuilderError::InvalidAttribute => "InvalidAttribute",
                BuilderError::InvalidTag => "InvalidTag",
                BuilderError::MissingPropertyValue => "MissingPropertyValue",
                BuilderError::InvalidValue => "InvalidValue",
                BuilderError::VersionMismatch => "VersionMismatch",
                BuilderError::DuplicateId => "DuplicateId",
                BuilderError::ObjectTypeRefused => "ObjectTypeRefused",
                BuilderError::TemplateMismatch => "TemplateMismatch",
                BuilderError::InvalidProperty => "InvalidProperty",
                BuilderError::InvalidSignal => "InvalidSignal",
                BuilderError::InvalidId => "InvalidId",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for BuilderError {
    type GlibType = ffi::GtkBuilderError;

    fn to_glib(self) -> ffi::GtkBuilderError {
        match self {
            BuilderError::InvalidTypeFunction => ffi::GTK_BUILDER_ERROR_INVALID_TYPE_FUNCTION,
            BuilderError::UnhandledTag => ffi::GTK_BUILDER_ERROR_UNHANDLED_TAG,
            BuilderError::MissingAttribute => ffi::GTK_BUILDER_ERROR_MISSING_ATTRIBUTE,
            BuilderError::InvalidAttribute => ffi::GTK_BUILDER_ERROR_INVALID_ATTRIBUTE,
            BuilderError::InvalidTag => ffi::GTK_BUILDER_ERROR_INVALID_TAG,
            BuilderError::MissingPropertyValue => ffi::GTK_BUILDER_ERROR_MISSING_PROPERTY_VALUE,
            BuilderError::InvalidValue => ffi::GTK_BUILDER_ERROR_INVALID_VALUE,
            BuilderError::VersionMismatch => ffi::GTK_BUILDER_ERROR_VERSION_MISMATCH,
            BuilderError::DuplicateId => ffi::GTK_BUILDER_ERROR_DUPLICATE_ID,
            BuilderError::ObjectTypeRefused => ffi::GTK_BUILDER_ERROR_OBJECT_TYPE_REFUSED,
            BuilderError::TemplateMismatch => ffi::GTK_BUILDER_ERROR_TEMPLATE_MISMATCH,
            BuilderError::InvalidProperty => ffi::GTK_BUILDER_ERROR_INVALID_PROPERTY,
            BuilderError::InvalidSignal => ffi::GTK_BUILDER_ERROR_INVALID_SIGNAL,
            BuilderError::InvalidId => ffi::GTK_BUILDER_ERROR_INVALID_ID,
            BuilderError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkBuilderError> for BuilderError {
    unsafe fn from_glib(value: ffi::GtkBuilderError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => BuilderError::InvalidTypeFunction,
            1 => BuilderError::UnhandledTag,
            2 => BuilderError::MissingAttribute,
            3 => BuilderError::InvalidAttribute,
            4 => BuilderError::InvalidTag,
            5 => BuilderError::MissingPropertyValue,
            6 => BuilderError::InvalidValue,
            7 => BuilderError::VersionMismatch,
            8 => BuilderError::DuplicateId,
            9 => BuilderError::ObjectTypeRefused,
            10 => BuilderError::TemplateMismatch,
            11 => BuilderError::InvalidProperty,
            12 => BuilderError::InvalidSignal,
            13 => BuilderError::InvalidId,
            value => BuilderError::__Unknown(value),
        }
    }
}

impl ErrorDomain for BuilderError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_builder_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(BuilderError::InvalidTypeFunction),
            1 => Some(BuilderError::UnhandledTag),
            2 => Some(BuilderError::MissingAttribute),
            3 => Some(BuilderError::InvalidAttribute),
            4 => Some(BuilderError::InvalidTag),
            5 => Some(BuilderError::MissingPropertyValue),
            6 => Some(BuilderError::InvalidValue),
            7 => Some(BuilderError::VersionMismatch),
            8 => Some(BuilderError::DuplicateId),
            9 => Some(BuilderError::ObjectTypeRefused),
            10 => Some(BuilderError::TemplateMismatch),
            11 => Some(BuilderError::InvalidProperty),
            12 => Some(BuilderError::InvalidSignal),
            13 => Some(BuilderError::InvalidId),
            value => Some(BuilderError::__Unknown(value)),
        }
    }
}

impl StaticType for BuilderError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_builder_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for BuilderError {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for BuilderError {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for BuilderError {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkButtonBoxStyle")]
pub enum ButtonBoxStyle {
    #[doc(alias = "GTK_BUTTONBOX_SPREAD")]
    Spread,
    #[doc(alias = "GTK_BUTTONBOX_EDGE")]
    Edge,
    #[doc(alias = "GTK_BUTTONBOX_START")]
    Start,
    #[doc(alias = "GTK_BUTTONBOX_END")]
    End,
    #[doc(alias = "GTK_BUTTONBOX_CENTER")]
    Center,
    #[doc(alias = "GTK_BUTTONBOX_EXPAND")]
    Expand,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ButtonBoxStyle {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ButtonBoxStyle::{}",
            match *self {
                ButtonBoxStyle::Spread => "Spread",
                ButtonBoxStyle::Edge => "Edge",
                ButtonBoxStyle::Start => "Start",
                ButtonBoxStyle::End => "End",
                ButtonBoxStyle::Center => "Center",
                ButtonBoxStyle::Expand => "Expand",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ButtonBoxStyle {
    type GlibType = ffi::GtkButtonBoxStyle;

    fn to_glib(self) -> ffi::GtkButtonBoxStyle {
        match self {
            ButtonBoxStyle::Spread => ffi::GTK_BUTTONBOX_SPREAD,
            ButtonBoxStyle::Edge => ffi::GTK_BUTTONBOX_EDGE,
            ButtonBoxStyle::Start => ffi::GTK_BUTTONBOX_START,
            ButtonBoxStyle::End => ffi::GTK_BUTTONBOX_END,
            ButtonBoxStyle::Center => ffi::GTK_BUTTONBOX_CENTER,
            ButtonBoxStyle::Expand => ffi::GTK_BUTTONBOX_EXPAND,
            ButtonBoxStyle::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkButtonBoxStyle> for ButtonBoxStyle {
    unsafe fn from_glib(value: ffi::GtkButtonBoxStyle) -> Self {
        skip_assert_initialized!();
        match value {
            1 => ButtonBoxStyle::Spread,
            2 => ButtonBoxStyle::Edge,
            3 => ButtonBoxStyle::Start,
            4 => ButtonBoxStyle::End,
            5 => ButtonBoxStyle::Center,
            6 => ButtonBoxStyle::Expand,
            value => ButtonBoxStyle::__Unknown(value),
        }
    }
}

impl StaticType for ButtonBoxStyle {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_button_box_style_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ButtonBoxStyle {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ButtonBoxStyle {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ButtonBoxStyle {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v3_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_16")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkButtonRole")]
pub enum ButtonRole {
    #[doc(alias = "GTK_BUTTON_ROLE_NORMAL")]
    Normal,
    #[doc(alias = "GTK_BUTTON_ROLE_CHECK")]
    Check,
    #[doc(alias = "GTK_BUTTON_ROLE_RADIO")]
    Radio,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v3_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_16")))]
impl fmt::Display for ButtonRole {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ButtonRole::{}",
            match *self {
                ButtonRole::Normal => "Normal",
                ButtonRole::Check => "Check",
                ButtonRole::Radio => "Radio",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v3_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_16")))]
#[doc(hidden)]
impl ToGlib for ButtonRole {
    type GlibType = ffi::GtkButtonRole;

    fn to_glib(self) -> ffi::GtkButtonRole {
        match self {
            ButtonRole::Normal => ffi::GTK_BUTTON_ROLE_NORMAL,
            ButtonRole::Check => ffi::GTK_BUTTON_ROLE_CHECK,
            ButtonRole::Radio => ffi::GTK_BUTTON_ROLE_RADIO,
            ButtonRole::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v3_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_16")))]
#[doc(hidden)]
impl FromGlib<ffi::GtkButtonRole> for ButtonRole {
    unsafe fn from_glib(value: ffi::GtkButtonRole) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ButtonRole::Normal,
            1 => ButtonRole::Check,
            2 => ButtonRole::Radio,
            value => ButtonRole::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v3_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_16")))]
impl StaticType for ButtonRole {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_button_role_get_type()) }
    }
}

#[cfg(any(feature = "v3_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_16")))]
impl<'a> FromValueOptional<'a> for ButtonRole {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v3_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_16")))]
impl<'a> FromValue<'a> for ButtonRole {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v3_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_16")))]
impl SetValue for ButtonRole {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkButtonsType")]
pub enum ButtonsType {
    #[doc(alias = "GTK_BUTTONS_NONE")]
    None,
    #[doc(alias = "GTK_BUTTONS_OK")]
    Ok,
    #[doc(alias = "GTK_BUTTONS_CLOSE")]
    Close,
    #[doc(alias = "GTK_BUTTONS_CANCEL")]
    Cancel,
    #[doc(alias = "GTK_BUTTONS_YES_NO")]
    YesNo,
    #[doc(alias = "GTK_BUTTONS_OK_CANCEL")]
    OkCancel,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ButtonsType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ButtonsType::{}",
            match *self {
                ButtonsType::None => "None",
                ButtonsType::Ok => "Ok",
                ButtonsType::Close => "Close",
                ButtonsType::Cancel => "Cancel",
                ButtonsType::YesNo => "YesNo",
                ButtonsType::OkCancel => "OkCancel",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ButtonsType {
    type GlibType = ffi::GtkButtonsType;

    fn to_glib(self) -> ffi::GtkButtonsType {
        match self {
            ButtonsType::None => ffi::GTK_BUTTONS_NONE,
            ButtonsType::Ok => ffi::GTK_BUTTONS_OK,
            ButtonsType::Close => ffi::GTK_BUTTONS_CLOSE,
            ButtonsType::Cancel => ffi::GTK_BUTTONS_CANCEL,
            ButtonsType::YesNo => ffi::GTK_BUTTONS_YES_NO,
            ButtonsType::OkCancel => ffi::GTK_BUTTONS_OK_CANCEL,
            ButtonsType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkButtonsType> for ButtonsType {
    unsafe fn from_glib(value: ffi::GtkButtonsType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ButtonsType::None,
            1 => ButtonsType::Ok,
            2 => ButtonsType::Close,
            3 => ButtonsType::Cancel,
            4 => ButtonsType::YesNo,
            5 => ButtonsType::OkCancel,
            value => ButtonsType::__Unknown(value),
        }
    }
}

impl StaticType for ButtonsType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_buttons_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ButtonsType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ButtonsType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ButtonsType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkCellRendererAccelMode")]
pub enum CellRendererAccelMode {
    #[doc(alias = "GTK_CELL_RENDERER_ACCEL_MODE_GTK")]
    Gtk,
    #[doc(alias = "GTK_CELL_RENDERER_ACCEL_MODE_OTHER")]
    Other,
    #[doc(alias = "GTK_CELL_RENDERER_ACCEL_MODE_MODIFIER_TAP")]
    ModifierTap,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CellRendererAccelMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CellRendererAccelMode::{}",
            match *self {
                CellRendererAccelMode::Gtk => "Gtk",
                CellRendererAccelMode::Other => "Other",
                CellRendererAccelMode::ModifierTap => "ModifierTap",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for CellRendererAccelMode {
    type GlibType = ffi::GtkCellRendererAccelMode;

    fn to_glib(self) -> ffi::GtkCellRendererAccelMode {
        match self {
            CellRendererAccelMode::Gtk => ffi::GTK_CELL_RENDERER_ACCEL_MODE_GTK,
            CellRendererAccelMode::Other => ffi::GTK_CELL_RENDERER_ACCEL_MODE_OTHER,
            CellRendererAccelMode::ModifierTap => ffi::GTK_CELL_RENDERER_ACCEL_MODE_MODIFIER_TAP,
            CellRendererAccelMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCellRendererAccelMode> for CellRendererAccelMode {
    unsafe fn from_glib(value: ffi::GtkCellRendererAccelMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CellRendererAccelMode::Gtk,
            1 => CellRendererAccelMode::Other,
            2 => CellRendererAccelMode::ModifierTap,
            value => CellRendererAccelMode::__Unknown(value),
        }
    }
}

impl StaticType for CellRendererAccelMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_cell_renderer_accel_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CellRendererAccelMode {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CellRendererAccelMode {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CellRendererAccelMode {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkCellRendererMode")]
pub enum CellRendererMode {
    #[doc(alias = "GTK_CELL_RENDERER_MODE_INERT")]
    Inert,
    #[doc(alias = "GTK_CELL_RENDERER_MODE_ACTIVATABLE")]
    Activatable,
    #[doc(alias = "GTK_CELL_RENDERER_MODE_EDITABLE")]
    Editable,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CellRendererMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CellRendererMode::{}",
            match *self {
                CellRendererMode::Inert => "Inert",
                CellRendererMode::Activatable => "Activatable",
                CellRendererMode::Editable => "Editable",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for CellRendererMode {
    type GlibType = ffi::GtkCellRendererMode;

    fn to_glib(self) -> ffi::GtkCellRendererMode {
        match self {
            CellRendererMode::Inert => ffi::GTK_CELL_RENDERER_MODE_INERT,
            CellRendererMode::Activatable => ffi::GTK_CELL_RENDERER_MODE_ACTIVATABLE,
            CellRendererMode::Editable => ffi::GTK_CELL_RENDERER_MODE_EDITABLE,
            CellRendererMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCellRendererMode> for CellRendererMode {
    unsafe fn from_glib(value: ffi::GtkCellRendererMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CellRendererMode::Inert,
            1 => CellRendererMode::Activatable,
            2 => CellRendererMode::Editable,
            value => CellRendererMode::__Unknown(value),
        }
    }
}

impl StaticType for CellRendererMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_cell_renderer_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CellRendererMode {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CellRendererMode {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CellRendererMode {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkCornerType")]
pub enum CornerType {
    #[doc(alias = "GTK_CORNER_TOP_LEFT")]
    TopLeft,
    #[doc(alias = "GTK_CORNER_BOTTOM_LEFT")]
    BottomLeft,
    #[doc(alias = "GTK_CORNER_TOP_RIGHT")]
    TopRight,
    #[doc(alias = "GTK_CORNER_BOTTOM_RIGHT")]
    BottomRight,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CornerType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CornerType::{}",
            match *self {
                CornerType::TopLeft => "TopLeft",
                CornerType::BottomLeft => "BottomLeft",
                CornerType::TopRight => "TopRight",
                CornerType::BottomRight => "BottomRight",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for CornerType {
    type GlibType = ffi::GtkCornerType;

    fn to_glib(self) -> ffi::GtkCornerType {
        match self {
            CornerType::TopLeft => ffi::GTK_CORNER_TOP_LEFT,
            CornerType::BottomLeft => ffi::GTK_CORNER_BOTTOM_LEFT,
            CornerType::TopRight => ffi::GTK_CORNER_TOP_RIGHT,
            CornerType::BottomRight => ffi::GTK_CORNER_BOTTOM_RIGHT,
            CornerType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCornerType> for CornerType {
    unsafe fn from_glib(value: ffi::GtkCornerType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CornerType::TopLeft,
            1 => CornerType::BottomLeft,
            2 => CornerType::TopRight,
            3 => CornerType::BottomRight,
            value => CornerType::__Unknown(value),
        }
    }
}

impl StaticType for CornerType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_corner_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CornerType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CornerType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CornerType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkCssProviderError")]
pub enum CssProviderError {
    #[doc(alias = "GTK_CSS_PROVIDER_ERROR_FAILED")]
    Failed,
    #[doc(alias = "GTK_CSS_PROVIDER_ERROR_SYNTAX")]
    Syntax,
    #[doc(alias = "GTK_CSS_PROVIDER_ERROR_IMPORT")]
    Import,
    #[doc(alias = "GTK_CSS_PROVIDER_ERROR_NAME")]
    Name,
    #[doc(alias = "GTK_CSS_PROVIDER_ERROR_DEPRECATED")]
    Deprecated,
    #[doc(alias = "GTK_CSS_PROVIDER_ERROR_UNKNOWN_VALUE")]
    UnknownValue,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CssProviderError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CssProviderError::{}",
            match *self {
                CssProviderError::Failed => "Failed",
                CssProviderError::Syntax => "Syntax",
                CssProviderError::Import => "Import",
                CssProviderError::Name => "Name",
                CssProviderError::Deprecated => "Deprecated",
                CssProviderError::UnknownValue => "UnknownValue",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for CssProviderError {
    type GlibType = ffi::GtkCssProviderError;

    fn to_glib(self) -> ffi::GtkCssProviderError {
        match self {
            CssProviderError::Failed => ffi::GTK_CSS_PROVIDER_ERROR_FAILED,
            CssProviderError::Syntax => ffi::GTK_CSS_PROVIDER_ERROR_SYNTAX,
            CssProviderError::Import => ffi::GTK_CSS_PROVIDER_ERROR_IMPORT,
            CssProviderError::Name => ffi::GTK_CSS_PROVIDER_ERROR_NAME,
            CssProviderError::Deprecated => ffi::GTK_CSS_PROVIDER_ERROR_DEPRECATED,
            CssProviderError::UnknownValue => ffi::GTK_CSS_PROVIDER_ERROR_UNKNOWN_VALUE,
            CssProviderError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCssProviderError> for CssProviderError {
    unsafe fn from_glib(value: ffi::GtkCssProviderError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CssProviderError::Failed,
            1 => CssProviderError::Syntax,
            2 => CssProviderError::Import,
            3 => CssProviderError::Name,
            4 => CssProviderError::Deprecated,
            5 => CssProviderError::UnknownValue,
            value => CssProviderError::__Unknown(value),
        }
    }
}

impl ErrorDomain for CssProviderError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_css_provider_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(CssProviderError::Failed),
            1 => Some(CssProviderError::Syntax),
            2 => Some(CssProviderError::Import),
            3 => Some(CssProviderError::Name),
            4 => Some(CssProviderError::Deprecated),
            5 => Some(CssProviderError::UnknownValue),
            _ => Some(CssProviderError::Failed),
        }
    }
}

impl StaticType for CssProviderError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_css_provider_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CssProviderError {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CssProviderError {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CssProviderError {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkCssSectionType")]
pub enum CssSectionType {
    #[doc(alias = "GTK_CSS_SECTION_DOCUMENT")]
    Document,
    #[doc(alias = "GTK_CSS_SECTION_IMPORT")]
    Import,
    #[doc(alias = "GTK_CSS_SECTION_COLOR_DEFINITION")]
    ColorDefinition,
    #[doc(alias = "GTK_CSS_SECTION_BINDING_SET")]
    BindingSet,
    #[doc(alias = "GTK_CSS_SECTION_RULESET")]
    Ruleset,
    #[doc(alias = "GTK_CSS_SECTION_SELECTOR")]
    Selector,
    #[doc(alias = "GTK_CSS_SECTION_DECLARATION")]
    Declaration,
    #[doc(alias = "GTK_CSS_SECTION_VALUE")]
    Value,
    #[doc(alias = "GTK_CSS_SECTION_KEYFRAMES")]
    Keyframes,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CssSectionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CssSectionType::{}",
            match *self {
                CssSectionType::Document => "Document",
                CssSectionType::Import => "Import",
                CssSectionType::ColorDefinition => "ColorDefinition",
                CssSectionType::BindingSet => "BindingSet",
                CssSectionType::Ruleset => "Ruleset",
                CssSectionType::Selector => "Selector",
                CssSectionType::Declaration => "Declaration",
                CssSectionType::Value => "Value",
                CssSectionType::Keyframes => "Keyframes",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for CssSectionType {
    type GlibType = ffi::GtkCssSectionType;

    fn to_glib(self) -> ffi::GtkCssSectionType {
        match self {
            CssSectionType::Document => ffi::GTK_CSS_SECTION_DOCUMENT,
            CssSectionType::Import => ffi::GTK_CSS_SECTION_IMPORT,
            CssSectionType::ColorDefinition => ffi::GTK_CSS_SECTION_COLOR_DEFINITION,
            CssSectionType::BindingSet => ffi::GTK_CSS_SECTION_BINDING_SET,
            CssSectionType::Ruleset => ffi::GTK_CSS_SECTION_RULESET,
            CssSectionType::Selector => ffi::GTK_CSS_SECTION_SELECTOR,
            CssSectionType::Declaration => ffi::GTK_CSS_SECTION_DECLARATION,
            CssSectionType::Value => ffi::GTK_CSS_SECTION_VALUE,
            CssSectionType::Keyframes => ffi::GTK_CSS_SECTION_KEYFRAMES,
            CssSectionType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCssSectionType> for CssSectionType {
    unsafe fn from_glib(value: ffi::GtkCssSectionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CssSectionType::Document,
            1 => CssSectionType::Import,
            2 => CssSectionType::ColorDefinition,
            3 => CssSectionType::BindingSet,
            4 => CssSectionType::Ruleset,
            5 => CssSectionType::Selector,
            6 => CssSectionType::Declaration,
            7 => CssSectionType::Value,
            8 => CssSectionType::Keyframes,
            value => CssSectionType::__Unknown(value),
        }
    }
}

impl StaticType for CssSectionType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_css_section_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CssSectionType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CssSectionType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CssSectionType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkDeleteType")]
pub enum DeleteType {
    #[doc(alias = "GTK_DELETE_CHARS")]
    Chars,
    #[doc(alias = "GTK_DELETE_WORD_ENDS")]
    WordEnds,
    #[doc(alias = "GTK_DELETE_WORDS")]
    Words,
    #[doc(alias = "GTK_DELETE_DISPLAY_LINES")]
    DisplayLines,
    #[doc(alias = "GTK_DELETE_DISPLAY_LINE_ENDS")]
    DisplayLineEnds,
    #[doc(alias = "GTK_DELETE_PARAGRAPH_ENDS")]
    ParagraphEnds,
    #[doc(alias = "GTK_DELETE_PARAGRAPHS")]
    Paragraphs,
    #[doc(alias = "GTK_DELETE_WHITESPACE")]
    Whitespace,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DeleteType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DeleteType::{}",
            match *self {
                DeleteType::Chars => "Chars",
                DeleteType::WordEnds => "WordEnds",
                DeleteType::Words => "Words",
                DeleteType::DisplayLines => "DisplayLines",
                DeleteType::DisplayLineEnds => "DisplayLineEnds",
                DeleteType::ParagraphEnds => "ParagraphEnds",
                DeleteType::Paragraphs => "Paragraphs",
                DeleteType::Whitespace => "Whitespace",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for DeleteType {
    type GlibType = ffi::GtkDeleteType;

    fn to_glib(self) -> ffi::GtkDeleteType {
        match self {
            DeleteType::Chars => ffi::GTK_DELETE_CHARS,
            DeleteType::WordEnds => ffi::GTK_DELETE_WORD_ENDS,
            DeleteType::Words => ffi::GTK_DELETE_WORDS,
            DeleteType::DisplayLines => ffi::GTK_DELETE_DISPLAY_LINES,
            DeleteType::DisplayLineEnds => ffi::GTK_DELETE_DISPLAY_LINE_ENDS,
            DeleteType::ParagraphEnds => ffi::GTK_DELETE_PARAGRAPH_ENDS,
            DeleteType::Paragraphs => ffi::GTK_DELETE_PARAGRAPHS,
            DeleteType::Whitespace => ffi::GTK_DELETE_WHITESPACE,
            DeleteType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkDeleteType> for DeleteType {
    unsafe fn from_glib(value: ffi::GtkDeleteType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => DeleteType::Chars,
            1 => DeleteType::WordEnds,
            2 => DeleteType::Words,
            3 => DeleteType::DisplayLines,
            4 => DeleteType::DisplayLineEnds,
            5 => DeleteType::ParagraphEnds,
            6 => DeleteType::Paragraphs,
            7 => DeleteType::Whitespace,
            value => DeleteType::__Unknown(value),
        }
    }
}

impl StaticType for DeleteType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_delete_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DeleteType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DeleteType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DeleteType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkDirectionType")]
pub enum DirectionType {
    #[doc(alias = "GTK_DIR_TAB_FORWARD")]
    TabForward,
    #[doc(alias = "GTK_DIR_TAB_BACKWARD")]
    TabBackward,
    #[doc(alias = "GTK_DIR_UP")]
    Up,
    #[doc(alias = "GTK_DIR_DOWN")]
    Down,
    #[doc(alias = "GTK_DIR_LEFT")]
    Left,
    #[doc(alias = "GTK_DIR_RIGHT")]
    Right,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DirectionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DirectionType::{}",
            match *self {
                DirectionType::TabForward => "TabForward",
                DirectionType::TabBackward => "TabBackward",
                DirectionType::Up => "Up",
                DirectionType::Down => "Down",
                DirectionType::Left => "Left",
                DirectionType::Right => "Right",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for DirectionType {
    type GlibType = ffi::GtkDirectionType;

    fn to_glib(self) -> ffi::GtkDirectionType {
        match self {
            DirectionType::TabForward => ffi::GTK_DIR_TAB_FORWARD,
            DirectionType::TabBackward => ffi::GTK_DIR_TAB_BACKWARD,
            DirectionType::Up => ffi::GTK_DIR_UP,
            DirectionType::Down => ffi::GTK_DIR_DOWN,
            DirectionType::Left => ffi::GTK_DIR_LEFT,
            DirectionType::Right => ffi::GTK_DIR_RIGHT,
            DirectionType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkDirectionType> for DirectionType {
    unsafe fn from_glib(value: ffi::GtkDirectionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => DirectionType::TabForward,
            1 => DirectionType::TabBackward,
            2 => DirectionType::Up,
            3 => DirectionType::Down,
            4 => DirectionType::Left,
            5 => DirectionType::Right,
            value => DirectionType::__Unknown(value),
        }
    }
}

impl StaticType for DirectionType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_direction_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DirectionType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DirectionType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DirectionType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkDragResult")]
pub enum DragResult {
    #[doc(alias = "GTK_DRAG_RESULT_SUCCESS")]
    Success,
    #[doc(alias = "GTK_DRAG_RESULT_NO_TARGET")]
    NoTarget,
    #[doc(alias = "GTK_DRAG_RESULT_USER_CANCELLED")]
    UserCancelled,
    #[doc(alias = "GTK_DRAG_RESULT_TIMEOUT_EXPIRED")]
    TimeoutExpired,
    #[doc(alias = "GTK_DRAG_RESULT_GRAB_BROKEN")]
    GrabBroken,
    #[doc(alias = "GTK_DRAG_RESULT_ERROR")]
    Error,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DragResult {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DragResult::{}",
            match *self {
                DragResult::Success => "Success",
                DragResult::NoTarget => "NoTarget",
                DragResult::UserCancelled => "UserCancelled",
                DragResult::TimeoutExpired => "TimeoutExpired",
                DragResult::GrabBroken => "GrabBroken",
                DragResult::Error => "Error",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for DragResult {
    type GlibType = ffi::GtkDragResult;

    fn to_glib(self) -> ffi::GtkDragResult {
        match self {
            DragResult::Success => ffi::GTK_DRAG_RESULT_SUCCESS,
            DragResult::NoTarget => ffi::GTK_DRAG_RESULT_NO_TARGET,
            DragResult::UserCancelled => ffi::GTK_DRAG_RESULT_USER_CANCELLED,
            DragResult::TimeoutExpired => ffi::GTK_DRAG_RESULT_TIMEOUT_EXPIRED,
            DragResult::GrabBroken => ffi::GTK_DRAG_RESULT_GRAB_BROKEN,
            DragResult::Error => ffi::GTK_DRAG_RESULT_ERROR,
            DragResult::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkDragResult> for DragResult {
    unsafe fn from_glib(value: ffi::GtkDragResult) -> Self {
        skip_assert_initialized!();
        match value {
            0 => DragResult::Success,
            1 => DragResult::NoTarget,
            2 => DragResult::UserCancelled,
            3 => DragResult::TimeoutExpired,
            4 => DragResult::GrabBroken,
            5 => DragResult::Error,
            value => DragResult::__Unknown(value),
        }
    }
}

impl StaticType for DragResult {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_drag_result_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DragResult {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DragResult {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DragResult {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkEntryIconPosition")]
pub enum EntryIconPosition {
    #[doc(alias = "GTK_ENTRY_ICON_PRIMARY")]
    Primary,
    #[doc(alias = "GTK_ENTRY_ICON_SECONDARY")]
    Secondary,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for EntryIconPosition {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "EntryIconPosition::{}",
            match *self {
                EntryIconPosition::Primary => "Primary",
                EntryIconPosition::Secondary => "Secondary",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for EntryIconPosition {
    type GlibType = ffi::GtkEntryIconPosition;

    fn to_glib(self) -> ffi::GtkEntryIconPosition {
        match self {
            EntryIconPosition::Primary => ffi::GTK_ENTRY_ICON_PRIMARY,
            EntryIconPosition::Secondary => ffi::GTK_ENTRY_ICON_SECONDARY,
            EntryIconPosition::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkEntryIconPosition> for EntryIconPosition {
    unsafe fn from_glib(value: ffi::GtkEntryIconPosition) -> Self {
        skip_assert_initialized!();
        match value {
            0 => EntryIconPosition::Primary,
            1 => EntryIconPosition::Secondary,
            value => EntryIconPosition::__Unknown(value),
        }
    }
}

impl StaticType for EntryIconPosition {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_entry_icon_position_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for EntryIconPosition {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for EntryIconPosition {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for EntryIconPosition {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkEventSequenceState")]
pub enum EventSequenceState {
    #[doc(alias = "GTK_EVENT_SEQUENCE_NONE")]
    None,
    #[doc(alias = "GTK_EVENT_SEQUENCE_CLAIMED")]
    Claimed,
    #[doc(alias = "GTK_EVENT_SEQUENCE_DENIED")]
    Denied,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for EventSequenceState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "EventSequenceState::{}",
            match *self {
                EventSequenceState::None => "None",
                EventSequenceState::Claimed => "Claimed",
                EventSequenceState::Denied => "Denied",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for EventSequenceState {
    type GlibType = ffi::GtkEventSequenceState;

    fn to_glib(self) -> ffi::GtkEventSequenceState {
        match self {
            EventSequenceState::None => ffi::GTK_EVENT_SEQUENCE_NONE,
            EventSequenceState::Claimed => ffi::GTK_EVENT_SEQUENCE_CLAIMED,
            EventSequenceState::Denied => ffi::GTK_EVENT_SEQUENCE_DENIED,
            EventSequenceState::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkEventSequenceState> for EventSequenceState {
    unsafe fn from_glib(value: ffi::GtkEventSequenceState) -> Self {
        skip_assert_initialized!();
        match value {
            0 => EventSequenceState::None,
            1 => EventSequenceState::Claimed,
            2 => EventSequenceState::Denied,
            value => EventSequenceState::__Unknown(value),
        }
    }
}

impl StaticType for EventSequenceState {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_event_sequence_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for EventSequenceState {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for EventSequenceState {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for EventSequenceState {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkFileChooserAction")]
pub enum FileChooserAction {
    #[doc(alias = "GTK_FILE_CHOOSER_ACTION_OPEN")]
    Open,
    #[doc(alias = "GTK_FILE_CHOOSER_ACTION_SAVE")]
    Save,
    #[doc(alias = "GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER")]
    SelectFolder,
    #[doc(alias = "GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER")]
    CreateFolder,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FileChooserAction {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FileChooserAction::{}",
            match *self {
                FileChooserAction::Open => "Open",
                FileChooserAction::Save => "Save",
                FileChooserAction::SelectFolder => "SelectFolder",
                FileChooserAction::CreateFolder => "CreateFolder",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for FileChooserAction {
    type GlibType = ffi::GtkFileChooserAction;

    fn to_glib(self) -> ffi::GtkFileChooserAction {
        match self {
            FileChooserAction::Open => ffi::GTK_FILE_CHOOSER_ACTION_OPEN,
            FileChooserAction::Save => ffi::GTK_FILE_CHOOSER_ACTION_SAVE,
            FileChooserAction::SelectFolder => ffi::GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER,
            FileChooserAction::CreateFolder => ffi::GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER,
            FileChooserAction::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkFileChooserAction> for FileChooserAction {
    unsafe fn from_glib(value: ffi::GtkFileChooserAction) -> Self {
        skip_assert_initialized!();
        match value {
            0 => FileChooserAction::Open,
            1 => FileChooserAction::Save,
            2 => FileChooserAction::SelectFolder,
            3 => FileChooserAction::CreateFolder,
            value => FileChooserAction::__Unknown(value),
        }
    }
}

impl StaticType for FileChooserAction {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_file_chooser_action_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FileChooserAction {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FileChooserAction {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FileChooserAction {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkFileChooserConfirmation")]
pub enum FileChooserConfirmation {
    #[doc(alias = "GTK_FILE_CHOOSER_CONFIRMATION_CONFIRM")]
    Confirm,
    #[doc(alias = "GTK_FILE_CHOOSER_CONFIRMATION_ACCEPT_FILENAME")]
    AcceptFilename,
    #[doc(alias = "GTK_FILE_CHOOSER_CONFIRMATION_SELECT_AGAIN")]
    SelectAgain,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FileChooserConfirmation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FileChooserConfirmation::{}",
            match *self {
                FileChooserConfirmation::Confirm => "Confirm",
                FileChooserConfirmation::AcceptFilename => "AcceptFilename",
                FileChooserConfirmation::SelectAgain => "SelectAgain",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for FileChooserConfirmation {
    type GlibType = ffi::GtkFileChooserConfirmation;

    fn to_glib(self) -> ffi::GtkFileChooserConfirmation {
        match self {
            FileChooserConfirmation::Confirm => ffi::GTK_FILE_CHOOSER_CONFIRMATION_CONFIRM,
            FileChooserConfirmation::AcceptFilename => {
                ffi::GTK_FILE_CHOOSER_CONFIRMATION_ACCEPT_FILENAME
            }
            FileChooserConfirmation::SelectAgain => ffi::GTK_FILE_CHOOSER_CONFIRMATION_SELECT_AGAIN,
            FileChooserConfirmation::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkFileChooserConfirmation> for FileChooserConfirmation {
    unsafe fn from_glib(value: ffi::GtkFileChooserConfirmation) -> Self {
        skip_assert_initialized!();
        match value {
            0 => FileChooserConfirmation::Confirm,
            1 => FileChooserConfirmation::AcceptFilename,
            2 => FileChooserConfirmation::SelectAgain,
            value => FileChooserConfirmation::__Unknown(value),
        }
    }
}

impl StaticType for FileChooserConfirmation {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_file_chooser_confirmation_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FileChooserConfirmation {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FileChooserConfirmation {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FileChooserConfirmation {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkFileChooserError")]
pub enum FileChooserError {
    #[doc(alias = "GTK_FILE_CHOOSER_ERROR_NONEXISTENT")]
    Nonexistent,
    #[doc(alias = "GTK_FILE_CHOOSER_ERROR_BAD_FILENAME")]
    BadFilename,
    #[doc(alias = "GTK_FILE_CHOOSER_ERROR_ALREADY_EXISTS")]
    AlreadyExists,
    #[doc(alias = "GTK_FILE_CHOOSER_ERROR_INCOMPLETE_HOSTNAME")]
    IncompleteHostname,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FileChooserError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FileChooserError::{}",
            match *self {
                FileChooserError::Nonexistent => "Nonexistent",
                FileChooserError::BadFilename => "BadFilename",
                FileChooserError::AlreadyExists => "AlreadyExists",
                FileChooserError::IncompleteHostname => "IncompleteHostname",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for FileChooserError {
    type GlibType = ffi::GtkFileChooserError;

    fn to_glib(self) -> ffi::GtkFileChooserError {
        match self {
            FileChooserError::Nonexistent => ffi::GTK_FILE_CHOOSER_ERROR_NONEXISTENT,
            FileChooserError::BadFilename => ffi::GTK_FILE_CHOOSER_ERROR_BAD_FILENAME,
            FileChooserError::AlreadyExists => ffi::GTK_FILE_CHOOSER_ERROR_ALREADY_EXISTS,
            FileChooserError::IncompleteHostname => ffi::GTK_FILE_CHOOSER_ERROR_INCOMPLETE_HOSTNAME,
            FileChooserError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkFileChooserError> for FileChooserError {
    unsafe fn from_glib(value: ffi::GtkFileChooserError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => FileChooserError::Nonexistent,
            1 => FileChooserError::BadFilename,
            2 => FileChooserError::AlreadyExists,
            3 => FileChooserError::IncompleteHostname,
            value => FileChooserError::__Unknown(value),
        }
    }
}

impl ErrorDomain for FileChooserError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_file_chooser_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(FileChooserError::Nonexistent),
            1 => Some(FileChooserError::BadFilename),
            2 => Some(FileChooserError::AlreadyExists),
            3 => Some(FileChooserError::IncompleteHostname),
            value => Some(FileChooserError::__Unknown(value)),
        }
    }
}

impl StaticType for FileChooserError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_file_chooser_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FileChooserError {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FileChooserError {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FileChooserError {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[deprecated]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkIMPreeditStyle")]
pub enum IMPreeditStyle {
    #[doc(alias = "GTK_IM_PREEDIT_NOTHING")]
    Nothing,
    #[doc(alias = "GTK_IM_PREEDIT_CALLBACK")]
    Callback,
    #[doc(alias = "GTK_IM_PREEDIT_NONE")]
    None,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for IMPreeditStyle {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "IMPreeditStyle::{}",
            match *self {
                IMPreeditStyle::Nothing => "Nothing",
                IMPreeditStyle::Callback => "Callback",
                IMPreeditStyle::None => "None",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for IMPreeditStyle {
    type GlibType = ffi::GtkIMPreeditStyle;

    fn to_glib(self) -> ffi::GtkIMPreeditStyle {
        match self {
            IMPreeditStyle::Nothing => ffi::GTK_IM_PREEDIT_NOTHING,
            IMPreeditStyle::Callback => ffi::GTK_IM_PREEDIT_CALLBACK,
            IMPreeditStyle::None => ffi::GTK_IM_PREEDIT_NONE,
            IMPreeditStyle::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIMPreeditStyle> for IMPreeditStyle {
    unsafe fn from_glib(value: ffi::GtkIMPreeditStyle) -> Self {
        skip_assert_initialized!();
        match value {
            0 => IMPreeditStyle::Nothing,
            1 => IMPreeditStyle::Callback,
            2 => IMPreeditStyle::None,
            value => IMPreeditStyle::__Unknown(value),
        }
    }
}

impl StaticType for IMPreeditStyle {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_im_preedit_style_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for IMPreeditStyle {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for IMPreeditStyle {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for IMPreeditStyle {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[deprecated]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkIMStatusStyle")]
pub enum IMStatusStyle {
    #[doc(alias = "GTK_IM_STATUS_NOTHING")]
    Nothing,
    #[doc(alias = "GTK_IM_STATUS_CALLBACK")]
    Callback,
    #[doc(alias = "GTK_IM_STATUS_NONE")]
    None,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for IMStatusStyle {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "IMStatusStyle::{}",
            match *self {
                IMStatusStyle::Nothing => "Nothing",
                IMStatusStyle::Callback => "Callback",
                IMStatusStyle::None => "None",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for IMStatusStyle {
    type GlibType = ffi::GtkIMStatusStyle;

    fn to_glib(self) -> ffi::GtkIMStatusStyle {
        match self {
            IMStatusStyle::Nothing => ffi::GTK_IM_STATUS_NOTHING,
            IMStatusStyle::Callback => ffi::GTK_IM_STATUS_CALLBACK,
            IMStatusStyle::None => ffi::GTK_IM_STATUS_NONE,
            IMStatusStyle::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIMStatusStyle> for IMStatusStyle {
    unsafe fn from_glib(value: ffi::GtkIMStatusStyle) -> Self {
        skip_assert_initialized!();
        match value {
            0 => IMStatusStyle::Nothing,
            1 => IMStatusStyle::Callback,
            2 => IMStatusStyle::None,
            value => IMStatusStyle::__Unknown(value),
        }
    }
}

impl StaticType for IMStatusStyle {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_im_status_style_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for IMStatusStyle {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for IMStatusStyle {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for IMStatusStyle {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkIconSize")]
pub enum IconSize {
    #[doc(alias = "GTK_ICON_SIZE_INVALID")]
    Invalid,
    #[doc(alias = "GTK_ICON_SIZE_MENU")]
    Menu,
    #[doc(alias = "GTK_ICON_SIZE_SMALL_TOOLBAR")]
    SmallToolbar,
    #[doc(alias = "GTK_ICON_SIZE_LARGE_TOOLBAR")]
    LargeToolbar,
    #[doc(alias = "GTK_ICON_SIZE_BUTTON")]
    Button,
    #[doc(alias = "GTK_ICON_SIZE_DND")]
    Dnd,
    #[doc(alias = "GTK_ICON_SIZE_DIALOG")]
    Dialog,
    #[doc(hidden)]
    __Unknown(i32),
}

impl IconSize {
    #[doc(alias = "gtk_icon_size_lookup")]
    pub fn lookup(self) -> Option<(i32, i32)> {
        assert_initialized_main_thread!();
        unsafe {
            let mut width = mem::MaybeUninit::uninit();
            let mut height = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gtk_icon_size_lookup(
                self.to_glib(),
                width.as_mut_ptr(),
                height.as_mut_ptr(),
            ));
            let width = width.assume_init();
            let height = height.assume_init();
            if ret {
                Some((width, height))
            } else {
                None
            }
        }
    }
}

impl fmt::Display for IconSize {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "IconSize::{}",
            match *self {
                IconSize::Invalid => "Invalid",
                IconSize::Menu => "Menu",
                IconSize::SmallToolbar => "SmallToolbar",
                IconSize::LargeToolbar => "LargeToolbar",
                IconSize::Button => "Button",
                IconSize::Dnd => "Dnd",
                IconSize::Dialog => "Dialog",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for IconSize {
    type GlibType = ffi::GtkIconSize;

    fn to_glib(self) -> ffi::GtkIconSize {
        match self {
            IconSize::Invalid => ffi::GTK_ICON_SIZE_INVALID,
            IconSize::Menu => ffi::GTK_ICON_SIZE_MENU,
            IconSize::SmallToolbar => ffi::GTK_ICON_SIZE_SMALL_TOOLBAR,
            IconSize::LargeToolbar => ffi::GTK_ICON_SIZE_LARGE_TOOLBAR,
            IconSize::Button => ffi::GTK_ICON_SIZE_BUTTON,
            IconSize::Dnd => ffi::GTK_ICON_SIZE_DND,
            IconSize::Dialog => ffi::GTK_ICON_SIZE_DIALOG,
            IconSize::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIconSize> for IconSize {
    unsafe fn from_glib(value: ffi::GtkIconSize) -> Self {
        skip_assert_initialized!();
        match value {
            0 => IconSize::Invalid,
            1 => IconSize::Menu,
            2 => IconSize::SmallToolbar,
            3 => IconSize::LargeToolbar,
            4 => IconSize::Button,
            5 => IconSize::Dnd,
            6 => IconSize::Dialog,
            value => IconSize::__Unknown(value),
        }
    }
}

impl StaticType for IconSize {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_icon_size_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for IconSize {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for IconSize {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for IconSize {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkIconThemeError")]
pub enum IconThemeError {
    #[doc(alias = "GTK_ICON_THEME_NOT_FOUND")]
    NotFound,
    #[doc(alias = "GTK_ICON_THEME_FAILED")]
    Failed,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for IconThemeError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "IconThemeError::{}",
            match *self {
                IconThemeError::NotFound => "NotFound",
                IconThemeError::Failed => "Failed",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for IconThemeError {
    type GlibType = ffi::GtkIconThemeError;

    fn to_glib(self) -> ffi::GtkIconThemeError {
        match self {
            IconThemeError::NotFound => ffi::GTK_ICON_THEME_NOT_FOUND,
            IconThemeError::Failed => ffi::GTK_ICON_THEME_FAILED,
            IconThemeError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIconThemeError> for IconThemeError {
    unsafe fn from_glib(value: ffi::GtkIconThemeError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => IconThemeError::NotFound,
            1 => IconThemeError::Failed,
            value => IconThemeError::__Unknown(value),
        }
    }
}

impl ErrorDomain for IconThemeError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_icon_theme_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(IconThemeError::NotFound),
            1 => Some(IconThemeError::Failed),
            _ => Some(IconThemeError::Failed),
        }
    }
}

impl StaticType for IconThemeError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_icon_theme_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for IconThemeError {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for IconThemeError {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for IconThemeError {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkIconViewDropPosition")]
pub enum IconViewDropPosition {
    #[doc(alias = "GTK_ICON_VIEW_NO_DROP")]
    NoDrop,
    #[doc(alias = "GTK_ICON_VIEW_DROP_INTO")]
    DropInto,
    #[doc(alias = "GTK_ICON_VIEW_DROP_LEFT")]
    DropLeft,
    #[doc(alias = "GTK_ICON_VIEW_DROP_RIGHT")]
    DropRight,
    #[doc(alias = "GTK_ICON_VIEW_DROP_ABOVE")]
    DropAbove,
    #[doc(alias = "GTK_ICON_VIEW_DROP_BELOW")]
    DropBelow,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for IconViewDropPosition {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "IconViewDropPosition::{}",
            match *self {
                IconViewDropPosition::NoDrop => "NoDrop",
                IconViewDropPosition::DropInto => "DropInto",
                IconViewDropPosition::DropLeft => "DropLeft",
                IconViewDropPosition::DropRight => "DropRight",
                IconViewDropPosition::DropAbove => "DropAbove",
                IconViewDropPosition::DropBelow => "DropBelow",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for IconViewDropPosition {
    type GlibType = ffi::GtkIconViewDropPosition;

    fn to_glib(self) -> ffi::GtkIconViewDropPosition {
        match self {
            IconViewDropPosition::NoDrop => ffi::GTK_ICON_VIEW_NO_DROP,
            IconViewDropPosition::DropInto => ffi::GTK_ICON_VIEW_DROP_INTO,
            IconViewDropPosition::DropLeft => ffi::GTK_ICON_VIEW_DROP_LEFT,
            IconViewDropPosition::DropRight => ffi::GTK_ICON_VIEW_DROP_RIGHT,
            IconViewDropPosition::DropAbove => ffi::GTK_ICON_VIEW_DROP_ABOVE,
            IconViewDropPosition::DropBelow => ffi::GTK_ICON_VIEW_DROP_BELOW,
            IconViewDropPosition::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIconViewDropPosition> for IconViewDropPosition {
    unsafe fn from_glib(value: ffi::GtkIconViewDropPosition) -> Self {
        skip_assert_initialized!();
        match value {
            0 => IconViewDropPosition::NoDrop,
            1 => IconViewDropPosition::DropInto,
            2 => IconViewDropPosition::DropLeft,
            3 => IconViewDropPosition::DropRight,
            4 => IconViewDropPosition::DropAbove,
            5 => IconViewDropPosition::DropBelow,
            value => IconViewDropPosition::__Unknown(value),
        }
    }
}

impl StaticType for IconViewDropPosition {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_icon_view_drop_position_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for IconViewDropPosition {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for IconViewDropPosition {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for IconViewDropPosition {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkImageType")]
pub enum ImageType {
    #[doc(alias = "GTK_IMAGE_EMPTY")]
    Empty,
    #[doc(alias = "GTK_IMAGE_PIXBUF")]
    Pixbuf,
    #[doc(alias = "GTK_IMAGE_STOCK")]
    Stock,
    #[doc(alias = "GTK_IMAGE_ICON_SET")]
    IconSet,
    #[doc(alias = "GTK_IMAGE_ANIMATION")]
    Animation,
    #[doc(alias = "GTK_IMAGE_ICON_NAME")]
    IconName,
    #[doc(alias = "GTK_IMAGE_GICON")]
    Gicon,
    #[doc(alias = "GTK_IMAGE_SURFACE")]
    Surface,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ImageType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ImageType::{}",
            match *self {
                ImageType::Empty => "Empty",
                ImageType::Pixbuf => "Pixbuf",
                ImageType::Stock => "Stock",
                ImageType::IconSet => "IconSet",
                ImageType::Animation => "Animation",
                ImageType::IconName => "IconName",
                ImageType::Gicon => "Gicon",
                ImageType::Surface => "Surface",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ImageType {
    type GlibType = ffi::GtkImageType;

    fn to_glib(self) -> ffi::GtkImageType {
        match self {
            ImageType::Empty => ffi::GTK_IMAGE_EMPTY,
            ImageType::Pixbuf => ffi::GTK_IMAGE_PIXBUF,
            ImageType::Stock => ffi::GTK_IMAGE_STOCK,
            ImageType::IconSet => ffi::GTK_IMAGE_ICON_SET,
            ImageType::Animation => ffi::GTK_IMAGE_ANIMATION,
            ImageType::IconName => ffi::GTK_IMAGE_ICON_NAME,
            ImageType::Gicon => ffi::GTK_IMAGE_GICON,
            ImageType::Surface => ffi::GTK_IMAGE_SURFACE,
            ImageType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkImageType> for ImageType {
    unsafe fn from_glib(value: ffi::GtkImageType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ImageType::Empty,
            1 => ImageType::Pixbuf,
            2 => ImageType::Stock,
            3 => ImageType::IconSet,
            4 => ImageType::Animation,
            5 => ImageType::IconName,
            6 => ImageType::Gicon,
            7 => ImageType::Surface,
            value => ImageType::__Unknown(value),
        }
    }
}

impl StaticType for ImageType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_image_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ImageType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ImageType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ImageType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkInputPurpose")]
pub enum InputPurpose {
    #[doc(alias = "GTK_INPUT_PURPOSE_FREE_FORM")]
    FreeForm,
    #[doc(alias = "GTK_INPUT_PURPOSE_ALPHA")]
    Alpha,
    #[doc(alias = "GTK_INPUT_PURPOSE_DIGITS")]
    Digits,
    #[doc(alias = "GTK_INPUT_PURPOSE_NUMBER")]
    Number,
    #[doc(alias = "GTK_INPUT_PURPOSE_PHONE")]
    Phone,
    #[doc(alias = "GTK_INPUT_PURPOSE_URL")]
    Url,
    #[doc(alias = "GTK_INPUT_PURPOSE_EMAIL")]
    Email,
    #[doc(alias = "GTK_INPUT_PURPOSE_NAME")]
    Name,
    #[doc(alias = "GTK_INPUT_PURPOSE_PASSWORD")]
    Password,
    #[doc(alias = "GTK_INPUT_PURPOSE_PIN")]
    Pin,
    #[doc(alias = "GTK_INPUT_PURPOSE_TERMINAL")]
    Terminal,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for InputPurpose {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "InputPurpose::{}",
            match *self {
                InputPurpose::FreeForm => "FreeForm",
                InputPurpose::Alpha => "Alpha",
                InputPurpose::Digits => "Digits",
                InputPurpose::Number => "Number",
                InputPurpose::Phone => "Phone",
                InputPurpose::Url => "Url",
                InputPurpose::Email => "Email",
                InputPurpose::Name => "Name",
                InputPurpose::Password => "Password",
                InputPurpose::Pin => "Pin",
                InputPurpose::Terminal => "Terminal",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for InputPurpose {
    type GlibType = ffi::GtkInputPurpose;

    fn to_glib(self) -> ffi::GtkInputPurpose {
        match self {
            InputPurpose::FreeForm => ffi::GTK_INPUT_PURPOSE_FREE_FORM,
            InputPurpose::Alpha => ffi::GTK_INPUT_PURPOSE_ALPHA,
            InputPurpose::Digits => ffi::GTK_INPUT_PURPOSE_DIGITS,
            InputPurpose::Number => ffi::GTK_INPUT_PURPOSE_NUMBER,
            InputPurpose::Phone => ffi::GTK_INPUT_PURPOSE_PHONE,
            InputPurpose::Url => ffi::GTK_INPUT_PURPOSE_URL,
            InputPurpose::Email => ffi::GTK_INPUT_PURPOSE_EMAIL,
            InputPurpose::Name => ffi::GTK_INPUT_PURPOSE_NAME,
            InputPurpose::Password => ffi::GTK_INPUT_PURPOSE_PASSWORD,
            InputPurpose::Pin => ffi::GTK_INPUT_PURPOSE_PIN,
            InputPurpose::Terminal => ffi::GTK_INPUT_PURPOSE_TERMINAL,
            InputPurpose::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkInputPurpose> for InputPurpose {
    unsafe fn from_glib(value: ffi::GtkInputPurpose) -> Self {
        skip_assert_initialized!();
        match value {
            0 => InputPurpose::FreeForm,
            1 => InputPurpose::Alpha,
            2 => InputPurpose::Digits,
            3 => InputPurpose::Number,
            4 => InputPurpose::Phone,
            5 => InputPurpose::Url,
            6 => InputPurpose::Email,
            7 => InputPurpose::Name,
            8 => InputPurpose::Password,
            9 => InputPurpose::Pin,
            10 => InputPurpose::Terminal,
            value => InputPurpose::__Unknown(value),
        }
    }
}

impl StaticType for InputPurpose {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_input_purpose_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for InputPurpose {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for InputPurpose {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for InputPurpose {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkJustification")]
pub enum Justification {
    #[doc(alias = "GTK_JUSTIFY_LEFT")]
    Left,
    #[doc(alias = "GTK_JUSTIFY_RIGHT")]
    Right,
    #[doc(alias = "GTK_JUSTIFY_CENTER")]
    Center,
    #[doc(alias = "GTK_JUSTIFY_FILL")]
    Fill,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Justification {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Justification::{}",
            match *self {
                Justification::Left => "Left",
                Justification::Right => "Right",
                Justification::Center => "Center",
                Justification::Fill => "Fill",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Justification {
    type GlibType = ffi::GtkJustification;

    fn to_glib(self) -> ffi::GtkJustification {
        match self {
            Justification::Left => ffi::GTK_JUSTIFY_LEFT,
            Justification::Right => ffi::GTK_JUSTIFY_RIGHT,
            Justification::Center => ffi::GTK_JUSTIFY_CENTER,
            Justification::Fill => ffi::GTK_JUSTIFY_FILL,
            Justification::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkJustification> for Justification {
    unsafe fn from_glib(value: ffi::GtkJustification) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Justification::Left,
            1 => Justification::Right,
            2 => Justification::Center,
            3 => Justification::Fill,
            value => Justification::__Unknown(value),
        }
    }
}

impl StaticType for Justification {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_justification_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Justification {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Justification {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Justification {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkLevelBarMode")]
pub enum LevelBarMode {
    #[doc(alias = "GTK_LEVEL_BAR_MODE_CONTINUOUS")]
    Continuous,
    #[doc(alias = "GTK_LEVEL_BAR_MODE_DISCRETE")]
    Discrete,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for LevelBarMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "LevelBarMode::{}",
            match *self {
                LevelBarMode::Continuous => "Continuous",
                LevelBarMode::Discrete => "Discrete",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for LevelBarMode {
    type GlibType = ffi::GtkLevelBarMode;

    fn to_glib(self) -> ffi::GtkLevelBarMode {
        match self {
            LevelBarMode::Continuous => ffi::GTK_LEVEL_BAR_MODE_CONTINUOUS,
            LevelBarMode::Discrete => ffi::GTK_LEVEL_BAR_MODE_DISCRETE,
            LevelBarMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkLevelBarMode> for LevelBarMode {
    unsafe fn from_glib(value: ffi::GtkLevelBarMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => LevelBarMode::Continuous,
            1 => LevelBarMode::Discrete,
            value => LevelBarMode::__Unknown(value),
        }
    }
}

impl StaticType for LevelBarMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_level_bar_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for LevelBarMode {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for LevelBarMode {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for LevelBarMode {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkLicense")]
pub enum License {
    #[doc(alias = "GTK_LICENSE_UNKNOWN")]
    Unknown,
    #[doc(alias = "GTK_LICENSE_CUSTOM")]
    Custom,
    #[doc(alias = "GTK_LICENSE_GPL_2_0")]
    Gpl20,
    #[doc(alias = "GTK_LICENSE_GPL_3_0")]
    Gpl30,
    #[doc(alias = "GTK_LICENSE_LGPL_2_1")]
    Lgpl21,
    #[doc(alias = "GTK_LICENSE_LGPL_3_0")]
    Lgpl30,
    #[doc(alias = "GTK_LICENSE_BSD")]
    Bsd,
    #[doc(alias = "GTK_LICENSE_MIT_X11")]
    MitX11,
    #[doc(alias = "GTK_LICENSE_ARTISTIC")]
    Artistic,
    #[doc(alias = "GTK_LICENSE_GPL_2_0_ONLY")]
    Gpl20Only,
    #[doc(alias = "GTK_LICENSE_GPL_3_0_ONLY")]
    Gpl30Only,
    #[doc(alias = "GTK_LICENSE_LGPL_2_1_ONLY")]
    Lgpl21Only,
    #[doc(alias = "GTK_LICENSE_LGPL_3_0_ONLY")]
    Lgpl30Only,
    #[doc(alias = "GTK_LICENSE_AGPL_3_0")]
    Agpl30,
    #[doc(alias = "GTK_LICENSE_AGPL_3_0_ONLY")]
    Agpl30Only,
    #[doc(alias = "GTK_LICENSE_BSD_3")]
    Bsd3,
    #[doc(alias = "GTK_LICENSE_APACHE_2_0")]
    Apache20,
    #[doc(alias = "GTK_LICENSE_MPL_2_0")]
    Mpl20,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for License {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "License::{}",
            match *self {
                License::Unknown => "Unknown",
                License::Custom => "Custom",
                License::Gpl20 => "Gpl20",
                License::Gpl30 => "Gpl30",
                License::Lgpl21 => "Lgpl21",
                License::Lgpl30 => "Lgpl30",
                License::Bsd => "Bsd",
                License::MitX11 => "MitX11",
                License::Artistic => "Artistic",
                License::Gpl20Only => "Gpl20Only",
                License::Gpl30Only => "Gpl30Only",
                License::Lgpl21Only => "Lgpl21Only",
                License::Lgpl30Only => "Lgpl30Only",
                License::Agpl30 => "Agpl30",
                License::Agpl30Only => "Agpl30Only",
                License::Bsd3 => "Bsd3",
                License::Apache20 => "Apache20",
                License::Mpl20 => "Mpl20",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for License {
    type GlibType = ffi::GtkLicense;

    fn to_glib(self) -> ffi::GtkLicense {
        match self {
            License::Unknown => ffi::GTK_LICENSE_UNKNOWN,
            License::Custom => ffi::GTK_LICENSE_CUSTOM,
            License::Gpl20 => ffi::GTK_LICENSE_GPL_2_0,
            License::Gpl30 => ffi::GTK_LICENSE_GPL_3_0,
            License::Lgpl21 => ffi::GTK_LICENSE_LGPL_2_1,
            License::Lgpl30 => ffi::GTK_LICENSE_LGPL_3_0,
            License::Bsd => ffi::GTK_LICENSE_BSD,
            License::MitX11 => ffi::GTK_LICENSE_MIT_X11,
            License::Artistic => ffi::GTK_LICENSE_ARTISTIC,
            License::Gpl20Only => ffi::GTK_LICENSE_GPL_2_0_ONLY,
            License::Gpl30Only => ffi::GTK_LICENSE_GPL_3_0_ONLY,
            License::Lgpl21Only => ffi::GTK_LICENSE_LGPL_2_1_ONLY,
            License::Lgpl30Only => ffi::GTK_LICENSE_LGPL_3_0_ONLY,
            License::Agpl30 => ffi::GTK_LICENSE_AGPL_3_0,
            License::Agpl30Only => ffi::GTK_LICENSE_AGPL_3_0_ONLY,
            License::Bsd3 => ffi::GTK_LICENSE_BSD_3,
            License::Apache20 => ffi::GTK_LICENSE_APACHE_2_0,
            License::Mpl20 => ffi::GTK_LICENSE_MPL_2_0,
            License::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkLicense> for License {
    unsafe fn from_glib(value: ffi::GtkLicense) -> Self {
        skip_assert_initialized!();
        match value {
            0 => License::Unknown,
            1 => License::Custom,
            2 => License::Gpl20,
            3 => License::Gpl30,
            4 => License::Lgpl21,
            5 => License::Lgpl30,
            6 => License::Bsd,
            7 => License::MitX11,
            8 => License::Artistic,
            9 => License::Gpl20Only,
            10 => License::Gpl30Only,
            11 => License::Lgpl21Only,
            12 => License::Lgpl30Only,
            13 => License::Agpl30,
            14 => License::Agpl30Only,
            15 => License::Bsd3,
            16 => License::Apache20,
            17 => License::Mpl20,
            value => License::__Unknown(value),
        }
    }
}

impl StaticType for License {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_license_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for License {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for License {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for License {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkMenuDirectionType")]
pub enum MenuDirectionType {
    #[doc(alias = "GTK_MENU_DIR_PARENT")]
    Parent,
    #[doc(alias = "GTK_MENU_DIR_CHILD")]
    Child,
    #[doc(alias = "GTK_MENU_DIR_NEXT")]
    Next,
    #[doc(alias = "GTK_MENU_DIR_PREV")]
    Prev,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for MenuDirectionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "MenuDirectionType::{}",
            match *self {
                MenuDirectionType::Parent => "Parent",
                MenuDirectionType::Child => "Child",
                MenuDirectionType::Next => "Next",
                MenuDirectionType::Prev => "Prev",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for MenuDirectionType {
    type GlibType = ffi::GtkMenuDirectionType;

    fn to_glib(self) -> ffi::GtkMenuDirectionType {
        match self {
            MenuDirectionType::Parent => ffi::GTK_MENU_DIR_PARENT,
            MenuDirectionType::Child => ffi::GTK_MENU_DIR_CHILD,
            MenuDirectionType::Next => ffi::GTK_MENU_DIR_NEXT,
            MenuDirectionType::Prev => ffi::GTK_MENU_DIR_PREV,
            MenuDirectionType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkMenuDirectionType> for MenuDirectionType {
    unsafe fn from_glib(value: ffi::GtkMenuDirectionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => MenuDirectionType::Parent,
            1 => MenuDirectionType::Child,
            2 => MenuDirectionType::Next,
            3 => MenuDirectionType::Prev,
            value => MenuDirectionType::__Unknown(value),
        }
    }
}

impl StaticType for MenuDirectionType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_menu_direction_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for MenuDirectionType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for MenuDirectionType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for MenuDirectionType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkMessageType")]
pub enum MessageType {
    #[doc(alias = "GTK_MESSAGE_INFO")]
    Info,
    #[doc(alias = "GTK_MESSAGE_WARNING")]
    Warning,
    #[doc(alias = "GTK_MESSAGE_QUESTION")]
    Question,
    #[doc(alias = "GTK_MESSAGE_ERROR")]
    Error,
    #[doc(alias = "GTK_MESSAGE_OTHER")]
    Other,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for MessageType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "MessageType::{}",
            match *self {
                MessageType::Info => "Info",
                MessageType::Warning => "Warning",
                MessageType::Question => "Question",
                MessageType::Error => "Error",
                MessageType::Other => "Other",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for MessageType {
    type GlibType = ffi::GtkMessageType;

    fn to_glib(self) -> ffi::GtkMessageType {
        match self {
            MessageType::Info => ffi::GTK_MESSAGE_INFO,
            MessageType::Warning => ffi::GTK_MESSAGE_WARNING,
            MessageType::Question => ffi::GTK_MESSAGE_QUESTION,
            MessageType::Error => ffi::GTK_MESSAGE_ERROR,
            MessageType::Other => ffi::GTK_MESSAGE_OTHER,
            MessageType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkMessageType> for MessageType {
    unsafe fn from_glib(value: ffi::GtkMessageType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => MessageType::Info,
            1 => MessageType::Warning,
            2 => MessageType::Question,
            3 => MessageType::Error,
            4 => MessageType::Other,
            value => MessageType::__Unknown(value),
        }
    }
}

impl StaticType for MessageType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_message_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for MessageType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for MessageType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for MessageType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkMovementStep")]
pub enum MovementStep {
    #[doc(alias = "GTK_MOVEMENT_LOGICAL_POSITIONS")]
    LogicalPositions,
    #[doc(alias = "GTK_MOVEMENT_VISUAL_POSITIONS")]
    VisualPositions,
    #[doc(alias = "GTK_MOVEMENT_WORDS")]
    Words,
    #[doc(alias = "GTK_MOVEMENT_DISPLAY_LINES")]
    DisplayLines,
    #[doc(alias = "GTK_MOVEMENT_DISPLAY_LINE_ENDS")]
    DisplayLineEnds,
    #[doc(alias = "GTK_MOVEMENT_PARAGRAPHS")]
    Paragraphs,
    #[doc(alias = "GTK_MOVEMENT_PARAGRAPH_ENDS")]
    ParagraphEnds,
    #[doc(alias = "GTK_MOVEMENT_PAGES")]
    Pages,
    #[doc(alias = "GTK_MOVEMENT_BUFFER_ENDS")]
    BufferEnds,
    #[doc(alias = "GTK_MOVEMENT_HORIZONTAL_PAGES")]
    HorizontalPages,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for MovementStep {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "MovementStep::{}",
            match *self {
                MovementStep::LogicalPositions => "LogicalPositions",
                MovementStep::VisualPositions => "VisualPositions",
                MovementStep::Words => "Words",
                MovementStep::DisplayLines => "DisplayLines",
                MovementStep::DisplayLineEnds => "DisplayLineEnds",
                MovementStep::Paragraphs => "Paragraphs",
                MovementStep::ParagraphEnds => "ParagraphEnds",
                MovementStep::Pages => "Pages",
                MovementStep::BufferEnds => "BufferEnds",
                MovementStep::HorizontalPages => "HorizontalPages",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for MovementStep {
    type GlibType = ffi::GtkMovementStep;

    fn to_glib(self) -> ffi::GtkMovementStep {
        match self {
            MovementStep::LogicalPositions => ffi::GTK_MOVEMENT_LOGICAL_POSITIONS,
            MovementStep::VisualPositions => ffi::GTK_MOVEMENT_VISUAL_POSITIONS,
            MovementStep::Words => ffi::GTK_MOVEMENT_WORDS,
            MovementStep::DisplayLines => ffi::GTK_MOVEMENT_DISPLAY_LINES,
            MovementStep::DisplayLineEnds => ffi::GTK_MOVEMENT_DISPLAY_LINE_ENDS,
            MovementStep::Paragraphs => ffi::GTK_MOVEMENT_PARAGRAPHS,
            MovementStep::ParagraphEnds => ffi::GTK_MOVEMENT_PARAGRAPH_ENDS,
            MovementStep::Pages => ffi::GTK_MOVEMENT_PAGES,
            MovementStep::BufferEnds => ffi::GTK_MOVEMENT_BUFFER_ENDS,
            MovementStep::HorizontalPages => ffi::GTK_MOVEMENT_HORIZONTAL_PAGES,
            MovementStep::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkMovementStep> for MovementStep {
    unsafe fn from_glib(value: ffi::GtkMovementStep) -> Self {
        skip_assert_initialized!();
        match value {
            0 => MovementStep::LogicalPositions,
            1 => MovementStep::VisualPositions,
            2 => MovementStep::Words,
            3 => MovementStep::DisplayLines,
            4 => MovementStep::DisplayLineEnds,
            5 => MovementStep::Paragraphs,
            6 => MovementStep::ParagraphEnds,
            7 => MovementStep::Pages,
            8 => MovementStep::BufferEnds,
            9 => MovementStep::HorizontalPages,
            value => MovementStep::__Unknown(value),
        }
    }
}

impl StaticType for MovementStep {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_movement_step_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for MovementStep {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for MovementStep {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for MovementStep {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkNotebookTab")]
pub enum NotebookTab {
    #[doc(alias = "GTK_NOTEBOOK_TAB_FIRST")]
    First,
    #[doc(alias = "GTK_NOTEBOOK_TAB_LAST")]
    Last,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for NotebookTab {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "NotebookTab::{}",
            match *self {
                NotebookTab::First => "First",
                NotebookTab::Last => "Last",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for NotebookTab {
    type GlibType = ffi::GtkNotebookTab;

    fn to_glib(self) -> ffi::GtkNotebookTab {
        match self {
            NotebookTab::First => ffi::GTK_NOTEBOOK_TAB_FIRST,
            NotebookTab::Last => ffi::GTK_NOTEBOOK_TAB_LAST,
            NotebookTab::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkNotebookTab> for NotebookTab {
    unsafe fn from_glib(value: ffi::GtkNotebookTab) -> Self {
        skip_assert_initialized!();
        match value {
            0 => NotebookTab::First,
            1 => NotebookTab::Last,
            value => NotebookTab::__Unknown(value),
        }
    }
}

impl StaticType for NotebookTab {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_notebook_tab_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for NotebookTab {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for NotebookTab {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for NotebookTab {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkNumberUpLayout")]
pub enum NumberUpLayout {
    #[doc(alias = "GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_TOP_TO_BOTTOM")]
    Lrtb,
    #[doc(alias = "GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_BOTTOM_TO_TOP")]
    Lrbt,
    #[doc(alias = "GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_TOP_TO_BOTTOM")]
    Rltb,
    #[doc(alias = "GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_BOTTOM_TO_TOP")]
    Rlbt,
    #[doc(alias = "GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_LEFT_TO_RIGHT")]
    Tblr,
    #[doc(alias = "GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_RIGHT_TO_LEFT")]
    Tbrl,
    #[doc(alias = "GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_LEFT_TO_RIGHT")]
    Btlr,
    #[doc(alias = "GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_RIGHT_TO_LEFT")]
    Btrl,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for NumberUpLayout {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "NumberUpLayout::{}",
            match *self {
                NumberUpLayout::Lrtb => "Lrtb",
                NumberUpLayout::Lrbt => "Lrbt",
                NumberUpLayout::Rltb => "Rltb",
                NumberUpLayout::Rlbt => "Rlbt",
                NumberUpLayout::Tblr => "Tblr",
                NumberUpLayout::Tbrl => "Tbrl",
                NumberUpLayout::Btlr => "Btlr",
                NumberUpLayout::Btrl => "Btrl",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for NumberUpLayout {
    type GlibType = ffi::GtkNumberUpLayout;

    fn to_glib(self) -> ffi::GtkNumberUpLayout {
        match self {
            NumberUpLayout::Lrtb => ffi::GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_TOP_TO_BOTTOM,
            NumberUpLayout::Lrbt => ffi::GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_BOTTOM_TO_TOP,
            NumberUpLayout::Rltb => ffi::GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_TOP_TO_BOTTOM,
            NumberUpLayout::Rlbt => ffi::GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_BOTTOM_TO_TOP,
            NumberUpLayout::Tblr => ffi::GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_LEFT_TO_RIGHT,
            NumberUpLayout::Tbrl => ffi::GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_RIGHT_TO_LEFT,
            NumberUpLayout::Btlr => ffi::GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_LEFT_TO_RIGHT,
            NumberUpLayout::Btrl => ffi::GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_RIGHT_TO_LEFT,
            NumberUpLayout::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkNumberUpLayout> for NumberUpLayout {
    unsafe fn from_glib(value: ffi::GtkNumberUpLayout) -> Self {
        skip_assert_initialized!();
        match value {
            0 => NumberUpLayout::Lrtb,
            1 => NumberUpLayout::Lrbt,
            2 => NumberUpLayout::Rltb,
            3 => NumberUpLayout::Rlbt,
            4 => NumberUpLayout::Tblr,
            5 => NumberUpLayout::Tbrl,
            6 => NumberUpLayout::Btlr,
            7 => NumberUpLayout::Btrl,
            value => NumberUpLayout::__Unknown(value),
        }
    }
}

impl StaticType for NumberUpLayout {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_number_up_layout_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for NumberUpLayout {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for NumberUpLayout {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for NumberUpLayout {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkOrientation")]
pub enum Orientation {
    #[doc(alias = "GTK_ORIENTATION_HORIZONTAL")]
    Horizontal,
    #[doc(alias = "GTK_ORIENTATION_VERTICAL")]
    Vertical,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Orientation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Orientation::{}",
            match *self {
                Orientation::Horizontal => "Horizontal",
                Orientation::Vertical => "Vertical",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Orientation {
    type GlibType = ffi::GtkOrientation;

    fn to_glib(self) -> ffi::GtkOrientation {
        match self {
            Orientation::Horizontal => ffi::GTK_ORIENTATION_HORIZONTAL,
            Orientation::Vertical => ffi::GTK_ORIENTATION_VERTICAL,
            Orientation::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkOrientation> for Orientation {
    unsafe fn from_glib(value: ffi::GtkOrientation) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Orientation::Horizontal,
            1 => Orientation::Vertical,
            value => Orientation::__Unknown(value),
        }
    }
}

impl StaticType for Orientation {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_orientation_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Orientation {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Orientation {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Orientation {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPackDirection")]
pub enum PackDirection {
    #[doc(alias = "GTK_PACK_DIRECTION_LTR")]
    Ltr,
    #[doc(alias = "GTK_PACK_DIRECTION_RTL")]
    Rtl,
    #[doc(alias = "GTK_PACK_DIRECTION_TTB")]
    Ttb,
    #[doc(alias = "GTK_PACK_DIRECTION_BTT")]
    Btt,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PackDirection {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PackDirection::{}",
            match *self {
                PackDirection::Ltr => "Ltr",
                PackDirection::Rtl => "Rtl",
                PackDirection::Ttb => "Ttb",
                PackDirection::Btt => "Btt",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PackDirection {
    type GlibType = ffi::GtkPackDirection;

    fn to_glib(self) -> ffi::GtkPackDirection {
        match self {
            PackDirection::Ltr => ffi::GTK_PACK_DIRECTION_LTR,
            PackDirection::Rtl => ffi::GTK_PACK_DIRECTION_RTL,
            PackDirection::Ttb => ffi::GTK_PACK_DIRECTION_TTB,
            PackDirection::Btt => ffi::GTK_PACK_DIRECTION_BTT,
            PackDirection::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPackDirection> for PackDirection {
    unsafe fn from_glib(value: ffi::GtkPackDirection) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PackDirection::Ltr,
            1 => PackDirection::Rtl,
            2 => PackDirection::Ttb,
            3 => PackDirection::Btt,
            value => PackDirection::__Unknown(value),
        }
    }
}

impl StaticType for PackDirection {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_pack_direction_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PackDirection {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PackDirection {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PackDirection {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPackType")]
pub enum PackType {
    #[doc(alias = "GTK_PACK_START")]
    Start,
    #[doc(alias = "GTK_PACK_END")]
    End,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PackType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PackType::{}",
            match *self {
                PackType::Start => "Start",
                PackType::End => "End",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PackType {
    type GlibType = ffi::GtkPackType;

    fn to_glib(self) -> ffi::GtkPackType {
        match self {
            PackType::Start => ffi::GTK_PACK_START,
            PackType::End => ffi::GTK_PACK_END,
            PackType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPackType> for PackType {
    unsafe fn from_glib(value: ffi::GtkPackType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PackType::Start,
            1 => PackType::End,
            value => PackType::__Unknown(value),
        }
    }
}

impl StaticType for PackType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_pack_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PackType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PackType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PackType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v3_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_22")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPadActionType")]
pub enum PadActionType {
    #[doc(alias = "GTK_PAD_ACTION_BUTTON")]
    Button,
    #[doc(alias = "GTK_PAD_ACTION_RING")]
    Ring,
    #[doc(alias = "GTK_PAD_ACTION_STRIP")]
    Strip,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v3_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_22")))]
impl fmt::Display for PadActionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PadActionType::{}",
            match *self {
                PadActionType::Button => "Button",
                PadActionType::Ring => "Ring",
                PadActionType::Strip => "Strip",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v3_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_22")))]
#[doc(hidden)]
impl ToGlib for PadActionType {
    type GlibType = ffi::GtkPadActionType;

    fn to_glib(self) -> ffi::GtkPadActionType {
        match self {
            PadActionType::Button => ffi::GTK_PAD_ACTION_BUTTON,
            PadActionType::Ring => ffi::GTK_PAD_ACTION_RING,
            PadActionType::Strip => ffi::GTK_PAD_ACTION_STRIP,
            PadActionType::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v3_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_22")))]
#[doc(hidden)]
impl FromGlib<ffi::GtkPadActionType> for PadActionType {
    unsafe fn from_glib(value: ffi::GtkPadActionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PadActionType::Button,
            1 => PadActionType::Ring,
            2 => PadActionType::Strip,
            value => PadActionType::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v3_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_22")))]
impl StaticType for PadActionType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_pad_action_type_get_type()) }
    }
}

#[cfg(any(feature = "v3_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_22")))]
impl<'a> FromValueOptional<'a> for PadActionType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v3_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_22")))]
impl<'a> FromValue<'a> for PadActionType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v3_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_22")))]
impl SetValue for PadActionType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPageOrientation")]
pub enum PageOrientation {
    #[doc(alias = "GTK_PAGE_ORIENTATION_PORTRAIT")]
    Portrait,
    #[doc(alias = "GTK_PAGE_ORIENTATION_LANDSCAPE")]
    Landscape,
    #[doc(alias = "GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT")]
    ReversePortrait,
    #[doc(alias = "GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE")]
    ReverseLandscape,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PageOrientation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PageOrientation::{}",
            match *self {
                PageOrientation::Portrait => "Portrait",
                PageOrientation::Landscape => "Landscape",
                PageOrientation::ReversePortrait => "ReversePortrait",
                PageOrientation::ReverseLandscape => "ReverseLandscape",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PageOrientation {
    type GlibType = ffi::GtkPageOrientation;

    fn to_glib(self) -> ffi::GtkPageOrientation {
        match self {
            PageOrientation::Portrait => ffi::GTK_PAGE_ORIENTATION_PORTRAIT,
            PageOrientation::Landscape => ffi::GTK_PAGE_ORIENTATION_LANDSCAPE,
            PageOrientation::ReversePortrait => ffi::GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT,
            PageOrientation::ReverseLandscape => ffi::GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE,
            PageOrientation::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPageOrientation> for PageOrientation {
    unsafe fn from_glib(value: ffi::GtkPageOrientation) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PageOrientation::Portrait,
            1 => PageOrientation::Landscape,
            2 => PageOrientation::ReversePortrait,
            3 => PageOrientation::ReverseLandscape,
            value => PageOrientation::__Unknown(value),
        }
    }
}

impl StaticType for PageOrientation {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_page_orientation_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PageOrientation {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PageOrientation {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PageOrientation {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPageSet")]
pub enum PageSet {
    #[doc(alias = "GTK_PAGE_SET_ALL")]
    All,
    #[doc(alias = "GTK_PAGE_SET_EVEN")]
    Even,
    #[doc(alias = "GTK_PAGE_SET_ODD")]
    Odd,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PageSet {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PageSet::{}",
            match *self {
                PageSet::All => "All",
                PageSet::Even => "Even",
                PageSet::Odd => "Odd",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PageSet {
    type GlibType = ffi::GtkPageSet;

    fn to_glib(self) -> ffi::GtkPageSet {
        match self {
            PageSet::All => ffi::GTK_PAGE_SET_ALL,
            PageSet::Even => ffi::GTK_PAGE_SET_EVEN,
            PageSet::Odd => ffi::GTK_PAGE_SET_ODD,
            PageSet::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPageSet> for PageSet {
    unsafe fn from_glib(value: ffi::GtkPageSet) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PageSet::All,
            1 => PageSet::Even,
            2 => PageSet::Odd,
            value => PageSet::__Unknown(value),
        }
    }
}

impl StaticType for PageSet {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_page_set_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PageSet {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PageSet {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PageSet {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPanDirection")]
pub enum PanDirection {
    #[doc(alias = "GTK_PAN_DIRECTION_LEFT")]
    Left,
    #[doc(alias = "GTK_PAN_DIRECTION_RIGHT")]
    Right,
    #[doc(alias = "GTK_PAN_DIRECTION_UP")]
    Up,
    #[doc(alias = "GTK_PAN_DIRECTION_DOWN")]
    Down,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PanDirection {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PanDirection::{}",
            match *self {
                PanDirection::Left => "Left",
                PanDirection::Right => "Right",
                PanDirection::Up => "Up",
                PanDirection::Down => "Down",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PanDirection {
    type GlibType = ffi::GtkPanDirection;

    fn to_glib(self) -> ffi::GtkPanDirection {
        match self {
            PanDirection::Left => ffi::GTK_PAN_DIRECTION_LEFT,
            PanDirection::Right => ffi::GTK_PAN_DIRECTION_RIGHT,
            PanDirection::Up => ffi::GTK_PAN_DIRECTION_UP,
            PanDirection::Down => ffi::GTK_PAN_DIRECTION_DOWN,
            PanDirection::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPanDirection> for PanDirection {
    unsafe fn from_glib(value: ffi::GtkPanDirection) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PanDirection::Left,
            1 => PanDirection::Right,
            2 => PanDirection::Up,
            3 => PanDirection::Down,
            value => PanDirection::__Unknown(value),
        }
    }
}

impl StaticType for PanDirection {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_pan_direction_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PanDirection {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PanDirection {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PanDirection {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPolicyType")]
pub enum PolicyType {
    #[doc(alias = "GTK_POLICY_ALWAYS")]
    Always,
    #[doc(alias = "GTK_POLICY_AUTOMATIC")]
    Automatic,
    #[doc(alias = "GTK_POLICY_NEVER")]
    Never,
    #[doc(alias = "GTK_POLICY_EXTERNAL")]
    External,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PolicyType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PolicyType::{}",
            match *self {
                PolicyType::Always => "Always",
                PolicyType::Automatic => "Automatic",
                PolicyType::Never => "Never",
                PolicyType::External => "External",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PolicyType {
    type GlibType = ffi::GtkPolicyType;

    fn to_glib(self) -> ffi::GtkPolicyType {
        match self {
            PolicyType::Always => ffi::GTK_POLICY_ALWAYS,
            PolicyType::Automatic => ffi::GTK_POLICY_AUTOMATIC,
            PolicyType::Never => ffi::GTK_POLICY_NEVER,
            PolicyType::External => ffi::GTK_POLICY_EXTERNAL,
            PolicyType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPolicyType> for PolicyType {
    unsafe fn from_glib(value: ffi::GtkPolicyType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PolicyType::Always,
            1 => PolicyType::Automatic,
            2 => PolicyType::Never,
            3 => PolicyType::External,
            value => PolicyType::__Unknown(value),
        }
    }
}

impl StaticType for PolicyType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_policy_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PolicyType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PolicyType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PolicyType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPopoverConstraint")]
pub enum PopoverConstraint {
    #[doc(alias = "GTK_POPOVER_CONSTRAINT_NONE")]
    None,
    #[doc(alias = "GTK_POPOVER_CONSTRAINT_WINDOW")]
    Window,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
impl fmt::Display for PopoverConstraint {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PopoverConstraint::{}",
            match *self {
                PopoverConstraint::None => "None",
                PopoverConstraint::Window => "Window",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
#[doc(hidden)]
impl ToGlib for PopoverConstraint {
    type GlibType = ffi::GtkPopoverConstraint;

    fn to_glib(self) -> ffi::GtkPopoverConstraint {
        match self {
            PopoverConstraint::None => ffi::GTK_POPOVER_CONSTRAINT_NONE,
            PopoverConstraint::Window => ffi::GTK_POPOVER_CONSTRAINT_WINDOW,
            PopoverConstraint::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
#[doc(hidden)]
impl FromGlib<ffi::GtkPopoverConstraint> for PopoverConstraint {
    unsafe fn from_glib(value: ffi::GtkPopoverConstraint) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PopoverConstraint::None,
            1 => PopoverConstraint::Window,
            value => PopoverConstraint::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
impl StaticType for PopoverConstraint {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_popover_constraint_get_type()) }
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
impl<'a> FromValueOptional<'a> for PopoverConstraint {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
impl<'a> FromValue<'a> for PopoverConstraint {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
impl SetValue for PopoverConstraint {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPositionType")]
pub enum PositionType {
    #[doc(alias = "GTK_POS_LEFT")]
    Left,
    #[doc(alias = "GTK_POS_RIGHT")]
    Right,
    #[doc(alias = "GTK_POS_TOP")]
    Top,
    #[doc(alias = "GTK_POS_BOTTOM")]
    Bottom,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PositionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PositionType::{}",
            match *self {
                PositionType::Left => "Left",
                PositionType::Right => "Right",
                PositionType::Top => "Top",
                PositionType::Bottom => "Bottom",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PositionType {
    type GlibType = ffi::GtkPositionType;

    fn to_glib(self) -> ffi::GtkPositionType {
        match self {
            PositionType::Left => ffi::GTK_POS_LEFT,
            PositionType::Right => ffi::GTK_POS_RIGHT,
            PositionType::Top => ffi::GTK_POS_TOP,
            PositionType::Bottom => ffi::GTK_POS_BOTTOM,
            PositionType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPositionType> for PositionType {
    unsafe fn from_glib(value: ffi::GtkPositionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PositionType::Left,
            1 => PositionType::Right,
            2 => PositionType::Top,
            3 => PositionType::Bottom,
            value => PositionType::__Unknown(value),
        }
    }
}

impl StaticType for PositionType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_position_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PositionType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PositionType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PositionType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPrintDuplex")]
pub enum PrintDuplex {
    #[doc(alias = "GTK_PRINT_DUPLEX_SIMPLEX")]
    Simplex,
    #[doc(alias = "GTK_PRINT_DUPLEX_HORIZONTAL")]
    Horizontal,
    #[doc(alias = "GTK_PRINT_DUPLEX_VERTICAL")]
    Vertical,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PrintDuplex {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PrintDuplex::{}",
            match *self {
                PrintDuplex::Simplex => "Simplex",
                PrintDuplex::Horizontal => "Horizontal",
                PrintDuplex::Vertical => "Vertical",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PrintDuplex {
    type GlibType = ffi::GtkPrintDuplex;

    fn to_glib(self) -> ffi::GtkPrintDuplex {
        match self {
            PrintDuplex::Simplex => ffi::GTK_PRINT_DUPLEX_SIMPLEX,
            PrintDuplex::Horizontal => ffi::GTK_PRINT_DUPLEX_HORIZONTAL,
            PrintDuplex::Vertical => ffi::GTK_PRINT_DUPLEX_VERTICAL,
            PrintDuplex::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintDuplex> for PrintDuplex {
    unsafe fn from_glib(value: ffi::GtkPrintDuplex) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PrintDuplex::Simplex,
            1 => PrintDuplex::Horizontal,
            2 => PrintDuplex::Vertical,
            value => PrintDuplex::__Unknown(value),
        }
    }
}

impl StaticType for PrintDuplex {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_print_duplex_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PrintDuplex {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PrintDuplex {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PrintDuplex {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPrintError")]
pub enum PrintError {
    #[doc(alias = "GTK_PRINT_ERROR_GENERAL")]
    General,
    #[doc(alias = "GTK_PRINT_ERROR_INTERNAL_ERROR")]
    InternalError,
    #[doc(alias = "GTK_PRINT_ERROR_NOMEM")]
    Nomem,
    #[doc(alias = "GTK_PRINT_ERROR_INVALID_FILE")]
    InvalidFile,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PrintError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PrintError::{}",
            match *self {
                PrintError::General => "General",
                PrintError::InternalError => "InternalError",
                PrintError::Nomem => "Nomem",
                PrintError::InvalidFile => "InvalidFile",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PrintError {
    type GlibType = ffi::GtkPrintError;

    fn to_glib(self) -> ffi::GtkPrintError {
        match self {
            PrintError::General => ffi::GTK_PRINT_ERROR_GENERAL,
            PrintError::InternalError => ffi::GTK_PRINT_ERROR_INTERNAL_ERROR,
            PrintError::Nomem => ffi::GTK_PRINT_ERROR_NOMEM,
            PrintError::InvalidFile => ffi::GTK_PRINT_ERROR_INVALID_FILE,
            PrintError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintError> for PrintError {
    unsafe fn from_glib(value: ffi::GtkPrintError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PrintError::General,
            1 => PrintError::InternalError,
            2 => PrintError::Nomem,
            3 => PrintError::InvalidFile,
            value => PrintError::__Unknown(value),
        }
    }
}

impl ErrorDomain for PrintError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_print_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(PrintError::General),
            1 => Some(PrintError::InternalError),
            2 => Some(PrintError::Nomem),
            3 => Some(PrintError::InvalidFile),
            value => Some(PrintError::__Unknown(value)),
        }
    }
}

impl StaticType for PrintError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_print_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PrintError {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PrintError {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PrintError {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPrintOperationAction")]
pub enum PrintOperationAction {
    #[doc(alias = "GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG")]
    PrintDialog,
    #[doc(alias = "GTK_PRINT_OPERATION_ACTION_PRINT")]
    Print,
    #[doc(alias = "GTK_PRINT_OPERATION_ACTION_PREVIEW")]
    Preview,
    #[doc(alias = "GTK_PRINT_OPERATION_ACTION_EXPORT")]
    Export,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PrintOperationAction {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PrintOperationAction::{}",
            match *self {
                PrintOperationAction::PrintDialog => "PrintDialog",
                PrintOperationAction::Print => "Print",
                PrintOperationAction::Preview => "Preview",
                PrintOperationAction::Export => "Export",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PrintOperationAction {
    type GlibType = ffi::GtkPrintOperationAction;

    fn to_glib(self) -> ffi::GtkPrintOperationAction {
        match self {
            PrintOperationAction::PrintDialog => ffi::GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
            PrintOperationAction::Print => ffi::GTK_PRINT_OPERATION_ACTION_PRINT,
            PrintOperationAction::Preview => ffi::GTK_PRINT_OPERATION_ACTION_PREVIEW,
            PrintOperationAction::Export => ffi::GTK_PRINT_OPERATION_ACTION_EXPORT,
            PrintOperationAction::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintOperationAction> for PrintOperationAction {
    unsafe fn from_glib(value: ffi::GtkPrintOperationAction) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PrintOperationAction::PrintDialog,
            1 => PrintOperationAction::Print,
            2 => PrintOperationAction::Preview,
            3 => PrintOperationAction::Export,
            value => PrintOperationAction::__Unknown(value),
        }
    }
}

impl StaticType for PrintOperationAction {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_print_operation_action_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PrintOperationAction {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PrintOperationAction {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PrintOperationAction {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPrintOperationResult")]
pub enum PrintOperationResult {
    #[doc(alias = "GTK_PRINT_OPERATION_RESULT_ERROR")]
    Error,
    #[doc(alias = "GTK_PRINT_OPERATION_RESULT_APPLY")]
    Apply,
    #[doc(alias = "GTK_PRINT_OPERATION_RESULT_CANCEL")]
    Cancel,
    #[doc(alias = "GTK_PRINT_OPERATION_RESULT_IN_PROGRESS")]
    InProgress,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PrintOperationResult {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PrintOperationResult::{}",
            match *self {
                PrintOperationResult::Error => "Error",
                PrintOperationResult::Apply => "Apply",
                PrintOperationResult::Cancel => "Cancel",
                PrintOperationResult::InProgress => "InProgress",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PrintOperationResult {
    type GlibType = ffi::GtkPrintOperationResult;

    fn to_glib(self) -> ffi::GtkPrintOperationResult {
        match self {
            PrintOperationResult::Error => ffi::GTK_PRINT_OPERATION_RESULT_ERROR,
            PrintOperationResult::Apply => ffi::GTK_PRINT_OPERATION_RESULT_APPLY,
            PrintOperationResult::Cancel => ffi::GTK_PRINT_OPERATION_RESULT_CANCEL,
            PrintOperationResult::InProgress => ffi::GTK_PRINT_OPERATION_RESULT_IN_PROGRESS,
            PrintOperationResult::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintOperationResult> for PrintOperationResult {
    unsafe fn from_glib(value: ffi::GtkPrintOperationResult) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PrintOperationResult::Error,
            1 => PrintOperationResult::Apply,
            2 => PrintOperationResult::Cancel,
            3 => PrintOperationResult::InProgress,
            value => PrintOperationResult::__Unknown(value),
        }
    }
}

impl StaticType for PrintOperationResult {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_print_operation_result_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PrintOperationResult {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PrintOperationResult {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PrintOperationResult {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPrintPages")]
pub enum PrintPages {
    #[doc(alias = "GTK_PRINT_PAGES_ALL")]
    All,
    #[doc(alias = "GTK_PRINT_PAGES_CURRENT")]
    Current,
    #[doc(alias = "GTK_PRINT_PAGES_RANGES")]
    Ranges,
    #[doc(alias = "GTK_PRINT_PAGES_SELECTION")]
    Selection,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PrintPages {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PrintPages::{}",
            match *self {
                PrintPages::All => "All",
                PrintPages::Current => "Current",
                PrintPages::Ranges => "Ranges",
                PrintPages::Selection => "Selection",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PrintPages {
    type GlibType = ffi::GtkPrintPages;

    fn to_glib(self) -> ffi::GtkPrintPages {
        match self {
            PrintPages::All => ffi::GTK_PRINT_PAGES_ALL,
            PrintPages::Current => ffi::GTK_PRINT_PAGES_CURRENT,
            PrintPages::Ranges => ffi::GTK_PRINT_PAGES_RANGES,
            PrintPages::Selection => ffi::GTK_PRINT_PAGES_SELECTION,
            PrintPages::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintPages> for PrintPages {
    unsafe fn from_glib(value: ffi::GtkPrintPages) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PrintPages::All,
            1 => PrintPages::Current,
            2 => PrintPages::Ranges,
            3 => PrintPages::Selection,
            value => PrintPages::__Unknown(value),
        }
    }
}

impl StaticType for PrintPages {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_print_pages_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PrintPages {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PrintPages {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PrintPages {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPrintQuality")]
pub enum PrintQuality {
    #[doc(alias = "GTK_PRINT_QUALITY_LOW")]
    Low,
    #[doc(alias = "GTK_PRINT_QUALITY_NORMAL")]
    Normal,
    #[doc(alias = "GTK_PRINT_QUALITY_HIGH")]
    High,
    #[doc(alias = "GTK_PRINT_QUALITY_DRAFT")]
    Draft,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PrintQuality {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PrintQuality::{}",
            match *self {
                PrintQuality::Low => "Low",
                PrintQuality::Normal => "Normal",
                PrintQuality::High => "High",
                PrintQuality::Draft => "Draft",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PrintQuality {
    type GlibType = ffi::GtkPrintQuality;

    fn to_glib(self) -> ffi::GtkPrintQuality {
        match self {
            PrintQuality::Low => ffi::GTK_PRINT_QUALITY_LOW,
            PrintQuality::Normal => ffi::GTK_PRINT_QUALITY_NORMAL,
            PrintQuality::High => ffi::GTK_PRINT_QUALITY_HIGH,
            PrintQuality::Draft => ffi::GTK_PRINT_QUALITY_DRAFT,
            PrintQuality::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintQuality> for PrintQuality {
    unsafe fn from_glib(value: ffi::GtkPrintQuality) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PrintQuality::Low,
            1 => PrintQuality::Normal,
            2 => PrintQuality::High,
            3 => PrintQuality::Draft,
            value => PrintQuality::__Unknown(value),
        }
    }
}

impl StaticType for PrintQuality {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_print_quality_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PrintQuality {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PrintQuality {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PrintQuality {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPrintStatus")]
pub enum PrintStatus {
    #[doc(alias = "GTK_PRINT_STATUS_INITIAL")]
    Initial,
    #[doc(alias = "GTK_PRINT_STATUS_PREPARING")]
    Preparing,
    #[doc(alias = "GTK_PRINT_STATUS_GENERATING_DATA")]
    GeneratingData,
    #[doc(alias = "GTK_PRINT_STATUS_SENDING_DATA")]
    SendingData,
    #[doc(alias = "GTK_PRINT_STATUS_PENDING")]
    Pending,
    #[doc(alias = "GTK_PRINT_STATUS_PENDING_ISSUE")]
    PendingIssue,
    #[doc(alias = "GTK_PRINT_STATUS_PRINTING")]
    Printing,
    #[doc(alias = "GTK_PRINT_STATUS_FINISHED")]
    Finished,
    #[doc(alias = "GTK_PRINT_STATUS_FINISHED_ABORTED")]
    FinishedAborted,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PrintStatus {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PrintStatus::{}",
            match *self {
                PrintStatus::Initial => "Initial",
                PrintStatus::Preparing => "Preparing",
                PrintStatus::GeneratingData => "GeneratingData",
                PrintStatus::SendingData => "SendingData",
                PrintStatus::Pending => "Pending",
                PrintStatus::PendingIssue => "PendingIssue",
                PrintStatus::Printing => "Printing",
                PrintStatus::Finished => "Finished",
                PrintStatus::FinishedAborted => "FinishedAborted",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PrintStatus {
    type GlibType = ffi::GtkPrintStatus;

    fn to_glib(self) -> ffi::GtkPrintStatus {
        match self {
            PrintStatus::Initial => ffi::GTK_PRINT_STATUS_INITIAL,
            PrintStatus::Preparing => ffi::GTK_PRINT_STATUS_PREPARING,
            PrintStatus::GeneratingData => ffi::GTK_PRINT_STATUS_GENERATING_DATA,
            PrintStatus::SendingData => ffi::GTK_PRINT_STATUS_SENDING_DATA,
            PrintStatus::Pending => ffi::GTK_PRINT_STATUS_PENDING,
            PrintStatus::PendingIssue => ffi::GTK_PRINT_STATUS_PENDING_ISSUE,
            PrintStatus::Printing => ffi::GTK_PRINT_STATUS_PRINTING,
            PrintStatus::Finished => ffi::GTK_PRINT_STATUS_FINISHED,
            PrintStatus::FinishedAborted => ffi::GTK_PRINT_STATUS_FINISHED_ABORTED,
            PrintStatus::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintStatus> for PrintStatus {
    unsafe fn from_glib(value: ffi::GtkPrintStatus) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PrintStatus::Initial,
            1 => PrintStatus::Preparing,
            2 => PrintStatus::GeneratingData,
            3 => PrintStatus::SendingData,
            4 => PrintStatus::Pending,
            5 => PrintStatus::PendingIssue,
            6 => PrintStatus::Printing,
            7 => PrintStatus::Finished,
            8 => PrintStatus::FinishedAborted,
            value => PrintStatus::__Unknown(value),
        }
    }
}

impl StaticType for PrintStatus {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_print_status_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PrintStatus {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PrintStatus {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PrintStatus {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkPropagationPhase")]
pub enum PropagationPhase {
    #[doc(alias = "GTK_PHASE_NONE")]
    None,
    #[doc(alias = "GTK_PHASE_CAPTURE")]
    Capture,
    #[doc(alias = "GTK_PHASE_BUBBLE")]
    Bubble,
    #[doc(alias = "GTK_PHASE_TARGET")]
    Target,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PropagationPhase {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PropagationPhase::{}",
            match *self {
                PropagationPhase::None => "None",
                PropagationPhase::Capture => "Capture",
                PropagationPhase::Bubble => "Bubble",
                PropagationPhase::Target => "Target",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PropagationPhase {
    type GlibType = ffi::GtkPropagationPhase;

    fn to_glib(self) -> ffi::GtkPropagationPhase {
        match self {
            PropagationPhase::None => ffi::GTK_PHASE_NONE,
            PropagationPhase::Capture => ffi::GTK_PHASE_CAPTURE,
            PropagationPhase::Bubble => ffi::GTK_PHASE_BUBBLE,
            PropagationPhase::Target => ffi::GTK_PHASE_TARGET,
            PropagationPhase::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPropagationPhase> for PropagationPhase {
    unsafe fn from_glib(value: ffi::GtkPropagationPhase) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PropagationPhase::None,
            1 => PropagationPhase::Capture,
            2 => PropagationPhase::Bubble,
            3 => PropagationPhase::Target,
            value => PropagationPhase::__Unknown(value),
        }
    }
}

impl StaticType for PropagationPhase {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_propagation_phase_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PropagationPhase {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PropagationPhase {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PropagationPhase {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkRecentChooserError")]
pub enum RecentChooserError {
    #[doc(alias = "GTK_RECENT_CHOOSER_ERROR_NOT_FOUND")]
    NotFound,
    #[doc(alias = "GTK_RECENT_CHOOSER_ERROR_INVALID_URI")]
    InvalidUri,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for RecentChooserError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "RecentChooserError::{}",
            match *self {
                RecentChooserError::NotFound => "NotFound",
                RecentChooserError::InvalidUri => "InvalidUri",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for RecentChooserError {
    type GlibType = ffi::GtkRecentChooserError;

    fn to_glib(self) -> ffi::GtkRecentChooserError {
        match self {
            RecentChooserError::NotFound => ffi::GTK_RECENT_CHOOSER_ERROR_NOT_FOUND,
            RecentChooserError::InvalidUri => ffi::GTK_RECENT_CHOOSER_ERROR_INVALID_URI,
            RecentChooserError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkRecentChooserError> for RecentChooserError {
    unsafe fn from_glib(value: ffi::GtkRecentChooserError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => RecentChooserError::NotFound,
            1 => RecentChooserError::InvalidUri,
            value => RecentChooserError::__Unknown(value),
        }
    }
}

impl ErrorDomain for RecentChooserError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_recent_chooser_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(RecentChooserError::NotFound),
            1 => Some(RecentChooserError::InvalidUri),
            value => Some(RecentChooserError::__Unknown(value)),
        }
    }
}

impl StaticType for RecentChooserError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_recent_chooser_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for RecentChooserError {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for RecentChooserError {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for RecentChooserError {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkRecentManagerError")]
pub enum RecentManagerError {
    #[doc(alias = "GTK_RECENT_MANAGER_ERROR_NOT_FOUND")]
    NotFound,
    #[doc(alias = "GTK_RECENT_MANAGER_ERROR_INVALID_URI")]
    InvalidUri,
    #[doc(alias = "GTK_RECENT_MANAGER_ERROR_INVALID_ENCODING")]
    InvalidEncoding,
    #[doc(alias = "GTK_RECENT_MANAGER_ERROR_NOT_REGISTERED")]
    NotRegistered,
    #[doc(alias = "GTK_RECENT_MANAGER_ERROR_READ")]
    Read,
    #[doc(alias = "GTK_RECENT_MANAGER_ERROR_WRITE")]
    Write,
    #[doc(alias = "GTK_RECENT_MANAGER_ERROR_UNKNOWN")]
    Unknown,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for RecentManagerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "RecentManagerError::{}",
            match *self {
                RecentManagerError::NotFound => "NotFound",
                RecentManagerError::InvalidUri => "InvalidUri",
                RecentManagerError::InvalidEncoding => "InvalidEncoding",
                RecentManagerError::NotRegistered => "NotRegistered",
                RecentManagerError::Read => "Read",
                RecentManagerError::Write => "Write",
                RecentManagerError::Unknown => "Unknown",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for RecentManagerError {
    type GlibType = ffi::GtkRecentManagerError;

    fn to_glib(self) -> ffi::GtkRecentManagerError {
        match self {
            RecentManagerError::NotFound => ffi::GTK_RECENT_MANAGER_ERROR_NOT_FOUND,
            RecentManagerError::InvalidUri => ffi::GTK_RECENT_MANAGER_ERROR_INVALID_URI,
            RecentManagerError::InvalidEncoding => ffi::GTK_RECENT_MANAGER_ERROR_INVALID_ENCODING,
            RecentManagerError::NotRegistered => ffi::GTK_RECENT_MANAGER_ERROR_NOT_REGISTERED,
            RecentManagerError::Read => ffi::GTK_RECENT_MANAGER_ERROR_READ,
            RecentManagerError::Write => ffi::GTK_RECENT_MANAGER_ERROR_WRITE,
            RecentManagerError::Unknown => ffi::GTK_RECENT_MANAGER_ERROR_UNKNOWN,
            RecentManagerError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkRecentManagerError> for RecentManagerError {
    unsafe fn from_glib(value: ffi::GtkRecentManagerError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => RecentManagerError::NotFound,
            1 => RecentManagerError::InvalidUri,
            2 => RecentManagerError::InvalidEncoding,
            3 => RecentManagerError::NotRegistered,
            4 => RecentManagerError::Read,
            5 => RecentManagerError::Write,
            6 => RecentManagerError::Unknown,
            value => RecentManagerError::__Unknown(value),
        }
    }
}

impl ErrorDomain for RecentManagerError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_recent_manager_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(RecentManagerError::NotFound),
            1 => Some(RecentManagerError::InvalidUri),
            2 => Some(RecentManagerError::InvalidEncoding),
            3 => Some(RecentManagerError::NotRegistered),
            4 => Some(RecentManagerError::Read),
            5 => Some(RecentManagerError::Write),
            6 => Some(RecentManagerError::Unknown),
            value => Some(RecentManagerError::__Unknown(value)),
        }
    }
}

impl StaticType for RecentManagerError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_recent_manager_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for RecentManagerError {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for RecentManagerError {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for RecentManagerError {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkRecentSortType")]
pub enum RecentSortType {
    #[doc(alias = "GTK_RECENT_SORT_NONE")]
    None,
    #[doc(alias = "GTK_RECENT_SORT_MRU")]
    Mru,
    #[doc(alias = "GTK_RECENT_SORT_LRU")]
    Lru,
    #[doc(alias = "GTK_RECENT_SORT_CUSTOM")]
    Custom,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for RecentSortType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "RecentSortType::{}",
            match *self {
                RecentSortType::None => "None",
                RecentSortType::Mru => "Mru",
                RecentSortType::Lru => "Lru",
                RecentSortType::Custom => "Custom",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for RecentSortType {
    type GlibType = ffi::GtkRecentSortType;

    fn to_glib(self) -> ffi::GtkRecentSortType {
        match self {
            RecentSortType::None => ffi::GTK_RECENT_SORT_NONE,
            RecentSortType::Mru => ffi::GTK_RECENT_SORT_MRU,
            RecentSortType::Lru => ffi::GTK_RECENT_SORT_LRU,
            RecentSortType::Custom => ffi::GTK_RECENT_SORT_CUSTOM,
            RecentSortType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkRecentSortType> for RecentSortType {
    unsafe fn from_glib(value: ffi::GtkRecentSortType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => RecentSortType::None,
            1 => RecentSortType::Mru,
            2 => RecentSortType::Lru,
            3 => RecentSortType::Custom,
            value => RecentSortType::__Unknown(value),
        }
    }
}

impl StaticType for RecentSortType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_recent_sort_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for RecentSortType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for RecentSortType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for RecentSortType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkReliefStyle")]
pub enum ReliefStyle {
    #[doc(alias = "GTK_RELIEF_NORMAL")]
    Normal,
    #[doc(alias = "GTK_RELIEF_HALF")]
    Half,
    #[doc(alias = "GTK_RELIEF_NONE")]
    None,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ReliefStyle {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ReliefStyle::{}",
            match *self {
                ReliefStyle::Normal => "Normal",
                ReliefStyle::Half => "Half",
                ReliefStyle::None => "None",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ReliefStyle {
    type GlibType = ffi::GtkReliefStyle;

    fn to_glib(self) -> ffi::GtkReliefStyle {
        match self {
            ReliefStyle::Normal => ffi::GTK_RELIEF_NORMAL,
            ReliefStyle::Half => ffi::GTK_RELIEF_HALF,
            ReliefStyle::None => ffi::GTK_RELIEF_NONE,
            ReliefStyle::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkReliefStyle> for ReliefStyle {
    unsafe fn from_glib(value: ffi::GtkReliefStyle) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ReliefStyle::Normal,
            1 => ReliefStyle::Half,
            2 => ReliefStyle::None,
            value => ReliefStyle::__Unknown(value),
        }
    }
}

impl StaticType for ReliefStyle {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_relief_style_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ReliefStyle {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ReliefStyle {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ReliefStyle {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkResizeMode")]
pub enum ResizeMode {
    #[doc(alias = "GTK_RESIZE_PARENT")]
    Parent,
    #[doc(alias = "GTK_RESIZE_QUEUE")]
    Queue,
    #[doc(alias = "GTK_RESIZE_IMMEDIATE")]
    Immediate,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ResizeMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ResizeMode::{}",
            match *self {
                ResizeMode::Parent => "Parent",
                ResizeMode::Queue => "Queue",
                ResizeMode::Immediate => "Immediate",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ResizeMode {
    type GlibType = ffi::GtkResizeMode;

    fn to_glib(self) -> ffi::GtkResizeMode {
        match self {
            ResizeMode::Parent => ffi::GTK_RESIZE_PARENT,
            ResizeMode::Queue => ffi::GTK_RESIZE_QUEUE,
            ResizeMode::Immediate => ffi::GTK_RESIZE_IMMEDIATE,
            ResizeMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkResizeMode> for ResizeMode {
    unsafe fn from_glib(value: ffi::GtkResizeMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ResizeMode::Parent,
            1 => ResizeMode::Queue,
            2 => ResizeMode::Immediate,
            value => ResizeMode::__Unknown(value),
        }
    }
}

impl StaticType for ResizeMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_resize_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ResizeMode {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ResizeMode {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ResizeMode {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkRevealerTransitionType")]
pub enum RevealerTransitionType {
    #[doc(alias = "GTK_REVEALER_TRANSITION_TYPE_NONE")]
    None,
    #[doc(alias = "GTK_REVEALER_TRANSITION_TYPE_CROSSFADE")]
    Crossfade,
    #[doc(alias = "GTK_REVEALER_TRANSITION_TYPE_SLIDE_RIGHT")]
    SlideRight,
    #[doc(alias = "GTK_REVEALER_TRANSITION_TYPE_SLIDE_LEFT")]
    SlideLeft,
    #[doc(alias = "GTK_REVEALER_TRANSITION_TYPE_SLIDE_UP")]
    SlideUp,
    #[doc(alias = "GTK_REVEALER_TRANSITION_TYPE_SLIDE_DOWN")]
    SlideDown,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for RevealerTransitionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "RevealerTransitionType::{}",
            match *self {
                RevealerTransitionType::None => "None",
                RevealerTransitionType::Crossfade => "Crossfade",
                RevealerTransitionType::SlideRight => "SlideRight",
                RevealerTransitionType::SlideLeft => "SlideLeft",
                RevealerTransitionType::SlideUp => "SlideUp",
                RevealerTransitionType::SlideDown => "SlideDown",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for RevealerTransitionType {
    type GlibType = ffi::GtkRevealerTransitionType;

    fn to_glib(self) -> ffi::GtkRevealerTransitionType {
        match self {
            RevealerTransitionType::None => ffi::GTK_REVEALER_TRANSITION_TYPE_NONE,
            RevealerTransitionType::Crossfade => ffi::GTK_REVEALER_TRANSITION_TYPE_CROSSFADE,
            RevealerTransitionType::SlideRight => ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_RIGHT,
            RevealerTransitionType::SlideLeft => ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_LEFT,
            RevealerTransitionType::SlideUp => ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_UP,
            RevealerTransitionType::SlideDown => ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_DOWN,
            RevealerTransitionType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkRevealerTransitionType> for RevealerTransitionType {
    unsafe fn from_glib(value: ffi::GtkRevealerTransitionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => RevealerTransitionType::None,
            1 => RevealerTransitionType::Crossfade,
            2 => RevealerTransitionType::SlideRight,
            3 => RevealerTransitionType::SlideLeft,
            4 => RevealerTransitionType::SlideUp,
            5 => RevealerTransitionType::SlideDown,
            value => RevealerTransitionType::__Unknown(value),
        }
    }
}

impl StaticType for RevealerTransitionType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_revealer_transition_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for RevealerTransitionType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for RevealerTransitionType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for RevealerTransitionType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkScrollStep")]
pub enum ScrollStep {
    #[doc(alias = "GTK_SCROLL_STEPS")]
    Steps,
    #[doc(alias = "GTK_SCROLL_PAGES")]
    Pages,
    #[doc(alias = "GTK_SCROLL_ENDS")]
    Ends,
    #[doc(alias = "GTK_SCROLL_HORIZONTAL_STEPS")]
    HorizontalSteps,
    #[doc(alias = "GTK_SCROLL_HORIZONTAL_PAGES")]
    HorizontalPages,
    #[doc(alias = "GTK_SCROLL_HORIZONTAL_ENDS")]
    HorizontalEnds,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ScrollStep {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ScrollStep::{}",
            match *self {
                ScrollStep::Steps => "Steps",
                ScrollStep::Pages => "Pages",
                ScrollStep::Ends => "Ends",
                ScrollStep::HorizontalSteps => "HorizontalSteps",
                ScrollStep::HorizontalPages => "HorizontalPages",
                ScrollStep::HorizontalEnds => "HorizontalEnds",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ScrollStep {
    type GlibType = ffi::GtkScrollStep;

    fn to_glib(self) -> ffi::GtkScrollStep {
        match self {
            ScrollStep::Steps => ffi::GTK_SCROLL_STEPS,
            ScrollStep::Pages => ffi::GTK_SCROLL_PAGES,
            ScrollStep::Ends => ffi::GTK_SCROLL_ENDS,
            ScrollStep::HorizontalSteps => ffi::GTK_SCROLL_HORIZONTAL_STEPS,
            ScrollStep::HorizontalPages => ffi::GTK_SCROLL_HORIZONTAL_PAGES,
            ScrollStep::HorizontalEnds => ffi::GTK_SCROLL_HORIZONTAL_ENDS,
            ScrollStep::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkScrollStep> for ScrollStep {
    unsafe fn from_glib(value: ffi::GtkScrollStep) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ScrollStep::Steps,
            1 => ScrollStep::Pages,
            2 => ScrollStep::Ends,
            3 => ScrollStep::HorizontalSteps,
            4 => ScrollStep::HorizontalPages,
            5 => ScrollStep::HorizontalEnds,
            value => ScrollStep::__Unknown(value),
        }
    }
}

impl StaticType for ScrollStep {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_scroll_step_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ScrollStep {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ScrollStep {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ScrollStep {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkScrollType")]
pub enum ScrollType {
    #[doc(alias = "GTK_SCROLL_NONE")]
    None,
    #[doc(alias = "GTK_SCROLL_JUMP")]
    Jump,
    #[doc(alias = "GTK_SCROLL_STEP_BACKWARD")]
    StepBackward,
    #[doc(alias = "GTK_SCROLL_STEP_FORWARD")]
    StepForward,
    #[doc(alias = "GTK_SCROLL_PAGE_BACKWARD")]
    PageBackward,
    #[doc(alias = "GTK_SCROLL_PAGE_FORWARD")]
    PageForward,
    #[doc(alias = "GTK_SCROLL_STEP_UP")]
    StepUp,
    #[doc(alias = "GTK_SCROLL_STEP_DOWN")]
    StepDown,
    #[doc(alias = "GTK_SCROLL_PAGE_UP")]
    PageUp,
    #[doc(alias = "GTK_SCROLL_PAGE_DOWN")]
    PageDown,
    #[doc(alias = "GTK_SCROLL_STEP_LEFT")]
    StepLeft,
    #[doc(alias = "GTK_SCROLL_STEP_RIGHT")]
    StepRight,
    #[doc(alias = "GTK_SCROLL_PAGE_LEFT")]
    PageLeft,
    #[doc(alias = "GTK_SCROLL_PAGE_RIGHT")]
    PageRight,
    #[doc(alias = "GTK_SCROLL_START")]
    Start,
    #[doc(alias = "GTK_SCROLL_END")]
    End,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ScrollType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ScrollType::{}",
            match *self {
                ScrollType::None => "None",
                ScrollType::Jump => "Jump",
                ScrollType::StepBackward => "StepBackward",
                ScrollType::StepForward => "StepForward",
                ScrollType::PageBackward => "PageBackward",
                ScrollType::PageForward => "PageForward",
                ScrollType::StepUp => "StepUp",
                ScrollType::StepDown => "StepDown",
                ScrollType::PageUp => "PageUp",
                ScrollType::PageDown => "PageDown",
                ScrollType::StepLeft => "StepLeft",
                ScrollType::StepRight => "StepRight",
                ScrollType::PageLeft => "PageLeft",
                ScrollType::PageRight => "PageRight",
                ScrollType::Start => "Start",
                ScrollType::End => "End",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ScrollType {
    type GlibType = ffi::GtkScrollType;

    fn to_glib(self) -> ffi::GtkScrollType {
        match self {
            ScrollType::None => ffi::GTK_SCROLL_NONE,
            ScrollType::Jump => ffi::GTK_SCROLL_JUMP,
            ScrollType::StepBackward => ffi::GTK_SCROLL_STEP_BACKWARD,
            ScrollType::StepForward => ffi::GTK_SCROLL_STEP_FORWARD,
            ScrollType::PageBackward => ffi::GTK_SCROLL_PAGE_BACKWARD,
            ScrollType::PageForward => ffi::GTK_SCROLL_PAGE_FORWARD,
            ScrollType::StepUp => ffi::GTK_SCROLL_STEP_UP,
            ScrollType::StepDown => ffi::GTK_SCROLL_STEP_DOWN,
            ScrollType::PageUp => ffi::GTK_SCROLL_PAGE_UP,
            ScrollType::PageDown => ffi::GTK_SCROLL_PAGE_DOWN,
            ScrollType::StepLeft => ffi::GTK_SCROLL_STEP_LEFT,
            ScrollType::StepRight => ffi::GTK_SCROLL_STEP_RIGHT,
            ScrollType::PageLeft => ffi::GTK_SCROLL_PAGE_LEFT,
            ScrollType::PageRight => ffi::GTK_SCROLL_PAGE_RIGHT,
            ScrollType::Start => ffi::GTK_SCROLL_START,
            ScrollType::End => ffi::GTK_SCROLL_END,
            ScrollType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkScrollType> for ScrollType {
    unsafe fn from_glib(value: ffi::GtkScrollType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ScrollType::None,
            1 => ScrollType::Jump,
            2 => ScrollType::StepBackward,
            3 => ScrollType::StepForward,
            4 => ScrollType::PageBackward,
            5 => ScrollType::PageForward,
            6 => ScrollType::StepUp,
            7 => ScrollType::StepDown,
            8 => ScrollType::PageUp,
            9 => ScrollType::PageDown,
            10 => ScrollType::StepLeft,
            11 => ScrollType::StepRight,
            12 => ScrollType::PageLeft,
            13 => ScrollType::PageRight,
            14 => ScrollType::Start,
            15 => ScrollType::End,
            value => ScrollType::__Unknown(value),
        }
    }
}

impl StaticType for ScrollType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_scroll_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ScrollType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ScrollType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ScrollType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkScrollablePolicy")]
pub enum ScrollablePolicy {
    #[doc(alias = "GTK_SCROLL_MINIMUM")]
    Minimum,
    #[doc(alias = "GTK_SCROLL_NATURAL")]
    Natural,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ScrollablePolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ScrollablePolicy::{}",
            match *self {
                ScrollablePolicy::Minimum => "Minimum",
                ScrollablePolicy::Natural => "Natural",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ScrollablePolicy {
    type GlibType = ffi::GtkScrollablePolicy;

    fn to_glib(self) -> ffi::GtkScrollablePolicy {
        match self {
            ScrollablePolicy::Minimum => ffi::GTK_SCROLL_MINIMUM,
            ScrollablePolicy::Natural => ffi::GTK_SCROLL_NATURAL,
            ScrollablePolicy::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkScrollablePolicy> for ScrollablePolicy {
    unsafe fn from_glib(value: ffi::GtkScrollablePolicy) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ScrollablePolicy::Minimum,
            1 => ScrollablePolicy::Natural,
            value => ScrollablePolicy::__Unknown(value),
        }
    }
}

impl StaticType for ScrollablePolicy {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_scrollable_policy_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ScrollablePolicy {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ScrollablePolicy {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ScrollablePolicy {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSelectionMode")]
pub enum SelectionMode {
    #[doc(alias = "GTK_SELECTION_NONE")]
    None,
    #[doc(alias = "GTK_SELECTION_SINGLE")]
    Single,
    #[doc(alias = "GTK_SELECTION_BROWSE")]
    Browse,
    #[doc(alias = "GTK_SELECTION_MULTIPLE")]
    Multiple,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SelectionMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SelectionMode::{}",
            match *self {
                SelectionMode::None => "None",
                SelectionMode::Single => "Single",
                SelectionMode::Browse => "Browse",
                SelectionMode::Multiple => "Multiple",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SelectionMode {
    type GlibType = ffi::GtkSelectionMode;

    fn to_glib(self) -> ffi::GtkSelectionMode {
        match self {
            SelectionMode::None => ffi::GTK_SELECTION_NONE,
            SelectionMode::Single => ffi::GTK_SELECTION_SINGLE,
            SelectionMode::Browse => ffi::GTK_SELECTION_BROWSE,
            SelectionMode::Multiple => ffi::GTK_SELECTION_MULTIPLE,
            SelectionMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSelectionMode> for SelectionMode {
    unsafe fn from_glib(value: ffi::GtkSelectionMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SelectionMode::None,
            1 => SelectionMode::Single,
            2 => SelectionMode::Browse,
            3 => SelectionMode::Multiple,
            value => SelectionMode::__Unknown(value),
        }
    }
}

impl StaticType for SelectionMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_selection_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SelectionMode {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SelectionMode {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SelectionMode {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSensitivityType")]
pub enum SensitivityType {
    #[doc(alias = "GTK_SENSITIVITY_AUTO")]
    Auto,
    #[doc(alias = "GTK_SENSITIVITY_ON")]
    On,
    #[doc(alias = "GTK_SENSITIVITY_OFF")]
    Off,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SensitivityType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SensitivityType::{}",
            match *self {
                SensitivityType::Auto => "Auto",
                SensitivityType::On => "On",
                SensitivityType::Off => "Off",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SensitivityType {
    type GlibType = ffi::GtkSensitivityType;

    fn to_glib(self) -> ffi::GtkSensitivityType {
        match self {
            SensitivityType::Auto => ffi::GTK_SENSITIVITY_AUTO,
            SensitivityType::On => ffi::GTK_SENSITIVITY_ON,
            SensitivityType::Off => ffi::GTK_SENSITIVITY_OFF,
            SensitivityType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSensitivityType> for SensitivityType {
    unsafe fn from_glib(value: ffi::GtkSensitivityType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SensitivityType::Auto,
            1 => SensitivityType::On,
            2 => SensitivityType::Off,
            value => SensitivityType::__Unknown(value),
        }
    }
}

impl StaticType for SensitivityType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_sensitivity_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SensitivityType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SensitivityType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SensitivityType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkShadowType")]
pub enum ShadowType {
    #[doc(alias = "GTK_SHADOW_NONE")]
    None,
    #[doc(alias = "GTK_SHADOW_IN")]
    In,
    #[doc(alias = "GTK_SHADOW_OUT")]
    Out,
    #[doc(alias = "GTK_SHADOW_ETCHED_IN")]
    EtchedIn,
    #[doc(alias = "GTK_SHADOW_ETCHED_OUT")]
    EtchedOut,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ShadowType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ShadowType::{}",
            match *self {
                ShadowType::None => "None",
                ShadowType::In => "In",
                ShadowType::Out => "Out",
                ShadowType::EtchedIn => "EtchedIn",
                ShadowType::EtchedOut => "EtchedOut",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ShadowType {
    type GlibType = ffi::GtkShadowType;

    fn to_glib(self) -> ffi::GtkShadowType {
        match self {
            ShadowType::None => ffi::GTK_SHADOW_NONE,
            ShadowType::In => ffi::GTK_SHADOW_IN,
            ShadowType::Out => ffi::GTK_SHADOW_OUT,
            ShadowType::EtchedIn => ffi::GTK_SHADOW_ETCHED_IN,
            ShadowType::EtchedOut => ffi::GTK_SHADOW_ETCHED_OUT,
            ShadowType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkShadowType> for ShadowType {
    unsafe fn from_glib(value: ffi::GtkShadowType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ShadowType::None,
            1 => ShadowType::In,
            2 => ShadowType::Out,
            3 => ShadowType::EtchedIn,
            4 => ShadowType::EtchedOut,
            value => ShadowType::__Unknown(value),
        }
    }
}

impl StaticType for ShadowType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_shadow_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ShadowType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ShadowType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ShadowType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkShortcutType")]
pub enum ShortcutType {
    #[doc(alias = "GTK_SHORTCUT_ACCELERATOR")]
    Accelerator,
    #[doc(alias = "GTK_SHORTCUT_GESTURE_PINCH")]
    GesturePinch,
    #[doc(alias = "GTK_SHORTCUT_GESTURE_STRETCH")]
    GestureStretch,
    #[doc(alias = "GTK_SHORTCUT_GESTURE_ROTATE_CLOCKWISE")]
    GestureRotateClockwise,
    #[doc(alias = "GTK_SHORTCUT_GESTURE_ROTATE_COUNTERCLOCKWISE")]
    GestureRotateCounterclockwise,
    #[doc(alias = "GTK_SHORTCUT_GESTURE_TWO_FINGER_SWIPE_LEFT")]
    GestureTwoFingerSwipeLeft,
    #[doc(alias = "GTK_SHORTCUT_GESTURE_TWO_FINGER_SWIPE_RIGHT")]
    GestureTwoFingerSwipeRight,
    #[doc(alias = "GTK_SHORTCUT_GESTURE")]
    Gesture,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
impl fmt::Display for ShortcutType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ShortcutType::{}",
            match *self {
                ShortcutType::Accelerator => "Accelerator",
                ShortcutType::GesturePinch => "GesturePinch",
                ShortcutType::GestureStretch => "GestureStretch",
                ShortcutType::GestureRotateClockwise => "GestureRotateClockwise",
                ShortcutType::GestureRotateCounterclockwise => "GestureRotateCounterclockwise",
                ShortcutType::GestureTwoFingerSwipeLeft => "GestureTwoFingerSwipeLeft",
                ShortcutType::GestureTwoFingerSwipeRight => "GestureTwoFingerSwipeRight",
                ShortcutType::Gesture => "Gesture",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
#[doc(hidden)]
impl ToGlib for ShortcutType {
    type GlibType = ffi::GtkShortcutType;

    fn to_glib(self) -> ffi::GtkShortcutType {
        match self {
            ShortcutType::Accelerator => ffi::GTK_SHORTCUT_ACCELERATOR,
            ShortcutType::GesturePinch => ffi::GTK_SHORTCUT_GESTURE_PINCH,
            ShortcutType::GestureStretch => ffi::GTK_SHORTCUT_GESTURE_STRETCH,
            ShortcutType::GestureRotateClockwise => ffi::GTK_SHORTCUT_GESTURE_ROTATE_CLOCKWISE,
            ShortcutType::GestureRotateCounterclockwise => {
                ffi::GTK_SHORTCUT_GESTURE_ROTATE_COUNTERCLOCKWISE
            }
            ShortcutType::GestureTwoFingerSwipeLeft => {
                ffi::GTK_SHORTCUT_GESTURE_TWO_FINGER_SWIPE_LEFT
            }
            ShortcutType::GestureTwoFingerSwipeRight => {
                ffi::GTK_SHORTCUT_GESTURE_TWO_FINGER_SWIPE_RIGHT
            }
            ShortcutType::Gesture => ffi::GTK_SHORTCUT_GESTURE,
            ShortcutType::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
#[doc(hidden)]
impl FromGlib<ffi::GtkShortcutType> for ShortcutType {
    unsafe fn from_glib(value: ffi::GtkShortcutType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ShortcutType::Accelerator,
            1 => ShortcutType::GesturePinch,
            2 => ShortcutType::GestureStretch,
            3 => ShortcutType::GestureRotateClockwise,
            4 => ShortcutType::GestureRotateCounterclockwise,
            5 => ShortcutType::GestureTwoFingerSwipeLeft,
            6 => ShortcutType::GestureTwoFingerSwipeRight,
            7 => ShortcutType::Gesture,
            value => ShortcutType::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
impl StaticType for ShortcutType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_shortcut_type_get_type()) }
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
impl<'a> FromValueOptional<'a> for ShortcutType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
impl<'a> FromValue<'a> for ShortcutType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
impl SetValue for ShortcutType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSizeGroupMode")]
pub enum SizeGroupMode {
    #[doc(alias = "GTK_SIZE_GROUP_NONE")]
    None,
    #[doc(alias = "GTK_SIZE_GROUP_HORIZONTAL")]
    Horizontal,
    #[doc(alias = "GTK_SIZE_GROUP_VERTICAL")]
    Vertical,
    #[doc(alias = "GTK_SIZE_GROUP_BOTH")]
    Both,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SizeGroupMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SizeGroupMode::{}",
            match *self {
                SizeGroupMode::None => "None",
                SizeGroupMode::Horizontal => "Horizontal",
                SizeGroupMode::Vertical => "Vertical",
                SizeGroupMode::Both => "Both",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SizeGroupMode {
    type GlibType = ffi::GtkSizeGroupMode;

    fn to_glib(self) -> ffi::GtkSizeGroupMode {
        match self {
            SizeGroupMode::None => ffi::GTK_SIZE_GROUP_NONE,
            SizeGroupMode::Horizontal => ffi::GTK_SIZE_GROUP_HORIZONTAL,
            SizeGroupMode::Vertical => ffi::GTK_SIZE_GROUP_VERTICAL,
            SizeGroupMode::Both => ffi::GTK_SIZE_GROUP_BOTH,
            SizeGroupMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSizeGroupMode> for SizeGroupMode {
    unsafe fn from_glib(value: ffi::GtkSizeGroupMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SizeGroupMode::None,
            1 => SizeGroupMode::Horizontal,
            2 => SizeGroupMode::Vertical,
            3 => SizeGroupMode::Both,
            value => SizeGroupMode::__Unknown(value),
        }
    }
}

impl StaticType for SizeGroupMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_size_group_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SizeGroupMode {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SizeGroupMode {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SizeGroupMode {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSizeRequestMode")]
pub enum SizeRequestMode {
    #[doc(alias = "GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH")]
    HeightForWidth,
    #[doc(alias = "GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT")]
    WidthForHeight,
    #[doc(alias = "GTK_SIZE_REQUEST_CONSTANT_SIZE")]
    ConstantSize,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SizeRequestMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SizeRequestMode::{}",
            match *self {
                SizeRequestMode::HeightForWidth => "HeightForWidth",
                SizeRequestMode::WidthForHeight => "WidthForHeight",
                SizeRequestMode::ConstantSize => "ConstantSize",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SizeRequestMode {
    type GlibType = ffi::GtkSizeRequestMode;

    fn to_glib(self) -> ffi::GtkSizeRequestMode {
        match self {
            SizeRequestMode::HeightForWidth => ffi::GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH,
            SizeRequestMode::WidthForHeight => ffi::GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT,
            SizeRequestMode::ConstantSize => ffi::GTK_SIZE_REQUEST_CONSTANT_SIZE,
            SizeRequestMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSizeRequestMode> for SizeRequestMode {
    unsafe fn from_glib(value: ffi::GtkSizeRequestMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SizeRequestMode::HeightForWidth,
            1 => SizeRequestMode::WidthForHeight,
            2 => SizeRequestMode::ConstantSize,
            value => SizeRequestMode::__Unknown(value),
        }
    }
}

impl StaticType for SizeRequestMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_size_request_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SizeRequestMode {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SizeRequestMode {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SizeRequestMode {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSortType")]
pub enum SortType {
    #[doc(alias = "GTK_SORT_ASCENDING")]
    Ascending,
    #[doc(alias = "GTK_SORT_DESCENDING")]
    Descending,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SortType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SortType::{}",
            match *self {
                SortType::Ascending => "Ascending",
                SortType::Descending => "Descending",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SortType {
    type GlibType = ffi::GtkSortType;

    fn to_glib(self) -> ffi::GtkSortType {
        match self {
            SortType::Ascending => ffi::GTK_SORT_ASCENDING,
            SortType::Descending => ffi::GTK_SORT_DESCENDING,
            SortType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSortType> for SortType {
    unsafe fn from_glib(value: ffi::GtkSortType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SortType::Ascending,
            1 => SortType::Descending,
            value => SortType::__Unknown(value),
        }
    }
}

impl StaticType for SortType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_sort_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SortType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SortType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SortType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSpinButtonUpdatePolicy")]
pub enum SpinButtonUpdatePolicy {
    #[doc(alias = "GTK_UPDATE_ALWAYS")]
    Always,
    #[doc(alias = "GTK_UPDATE_IF_VALID")]
    IfValid,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SpinButtonUpdatePolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SpinButtonUpdatePolicy::{}",
            match *self {
                SpinButtonUpdatePolicy::Always => "Always",
                SpinButtonUpdatePolicy::IfValid => "IfValid",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SpinButtonUpdatePolicy {
    type GlibType = ffi::GtkSpinButtonUpdatePolicy;

    fn to_glib(self) -> ffi::GtkSpinButtonUpdatePolicy {
        match self {
            SpinButtonUpdatePolicy::Always => ffi::GTK_UPDATE_ALWAYS,
            SpinButtonUpdatePolicy::IfValid => ffi::GTK_UPDATE_IF_VALID,
            SpinButtonUpdatePolicy::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSpinButtonUpdatePolicy> for SpinButtonUpdatePolicy {
    unsafe fn from_glib(value: ffi::GtkSpinButtonUpdatePolicy) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SpinButtonUpdatePolicy::Always,
            1 => SpinButtonUpdatePolicy::IfValid,
            value => SpinButtonUpdatePolicy::__Unknown(value),
        }
    }
}

impl StaticType for SpinButtonUpdatePolicy {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_spin_button_update_policy_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SpinButtonUpdatePolicy {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SpinButtonUpdatePolicy {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SpinButtonUpdatePolicy {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSpinType")]
pub enum SpinType {
    #[doc(alias = "GTK_SPIN_STEP_FORWARD")]
    StepForward,
    #[doc(alias = "GTK_SPIN_STEP_BACKWARD")]
    StepBackward,
    #[doc(alias = "GTK_SPIN_PAGE_FORWARD")]
    PageForward,
    #[doc(alias = "GTK_SPIN_PAGE_BACKWARD")]
    PageBackward,
    #[doc(alias = "GTK_SPIN_HOME")]
    Home,
    #[doc(alias = "GTK_SPIN_END")]
    End,
    #[doc(alias = "GTK_SPIN_USER_DEFINED")]
    UserDefined,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SpinType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SpinType::{}",
            match *self {
                SpinType::StepForward => "StepForward",
                SpinType::StepBackward => "StepBackward",
                SpinType::PageForward => "PageForward",
                SpinType::PageBackward => "PageBackward",
                SpinType::Home => "Home",
                SpinType::End => "End",
                SpinType::UserDefined => "UserDefined",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SpinType {
    type GlibType = ffi::GtkSpinType;

    fn to_glib(self) -> ffi::GtkSpinType {
        match self {
            SpinType::StepForward => ffi::GTK_SPIN_STEP_FORWARD,
            SpinType::StepBackward => ffi::GTK_SPIN_STEP_BACKWARD,
            SpinType::PageForward => ffi::GTK_SPIN_PAGE_FORWARD,
            SpinType::PageBackward => ffi::GTK_SPIN_PAGE_BACKWARD,
            SpinType::Home => ffi::GTK_SPIN_HOME,
            SpinType::End => ffi::GTK_SPIN_END,
            SpinType::UserDefined => ffi::GTK_SPIN_USER_DEFINED,
            SpinType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSpinType> for SpinType {
    unsafe fn from_glib(value: ffi::GtkSpinType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SpinType::StepForward,
            1 => SpinType::StepBackward,
            2 => SpinType::PageForward,
            3 => SpinType::PageBackward,
            4 => SpinType::Home,
            5 => SpinType::End,
            6 => SpinType::UserDefined,
            value => SpinType::__Unknown(value),
        }
    }
}

impl StaticType for SpinType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_spin_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SpinType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SpinType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SpinType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkStackTransitionType")]
pub enum StackTransitionType {
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_NONE")]
    None,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_CROSSFADE")]
    Crossfade,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_SLIDE_RIGHT")]
    SlideRight,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT")]
    SlideLeft,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_SLIDE_UP")]
    SlideUp,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_SLIDE_DOWN")]
    SlideDown,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT_RIGHT")]
    SlideLeftRight,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_SLIDE_UP_DOWN")]
    SlideUpDown,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_OVER_UP")]
    OverUp,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_OVER_DOWN")]
    OverDown,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_OVER_LEFT")]
    OverLeft,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_OVER_RIGHT")]
    OverRight,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_UNDER_UP")]
    UnderUp,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_UNDER_DOWN")]
    UnderDown,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_UNDER_LEFT")]
    UnderLeft,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_UNDER_RIGHT")]
    UnderRight,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_OVER_UP_DOWN")]
    OverUpDown,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_OVER_DOWN_UP")]
    OverDownUp,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_OVER_LEFT_RIGHT")]
    OverLeftRight,
    #[doc(alias = "GTK_STACK_TRANSITION_TYPE_OVER_RIGHT_LEFT")]
    OverRightLeft,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for StackTransitionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "StackTransitionType::{}",
            match *self {
                StackTransitionType::None => "None",
                StackTransitionType::Crossfade => "Crossfade",
                StackTransitionType::SlideRight => "SlideRight",
                StackTransitionType::SlideLeft => "SlideLeft",
                StackTransitionType::SlideUp => "SlideUp",
                StackTransitionType::SlideDown => "SlideDown",
                StackTransitionType::SlideLeftRight => "SlideLeftRight",
                StackTransitionType::SlideUpDown => "SlideUpDown",
                StackTransitionType::OverUp => "OverUp",
                StackTransitionType::OverDown => "OverDown",
                StackTransitionType::OverLeft => "OverLeft",
                StackTransitionType::OverRight => "OverRight",
                StackTransitionType::UnderUp => "UnderUp",
                StackTransitionType::UnderDown => "UnderDown",
                StackTransitionType::UnderLeft => "UnderLeft",
                StackTransitionType::UnderRight => "UnderRight",
                StackTransitionType::OverUpDown => "OverUpDown",
                StackTransitionType::OverDownUp => "OverDownUp",
                StackTransitionType::OverLeftRight => "OverLeftRight",
                StackTransitionType::OverRightLeft => "OverRightLeft",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for StackTransitionType {
    type GlibType = ffi::GtkStackTransitionType;

    fn to_glib(self) -> ffi::GtkStackTransitionType {
        match self {
            StackTransitionType::None => ffi::GTK_STACK_TRANSITION_TYPE_NONE,
            StackTransitionType::Crossfade => ffi::GTK_STACK_TRANSITION_TYPE_CROSSFADE,
            StackTransitionType::SlideRight => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_RIGHT,
            StackTransitionType::SlideLeft => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT,
            StackTransitionType::SlideUp => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_UP,
            StackTransitionType::SlideDown => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_DOWN,
            StackTransitionType::SlideLeftRight => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT_RIGHT,
            StackTransitionType::SlideUpDown => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_UP_DOWN,
            StackTransitionType::OverUp => ffi::GTK_STACK_TRANSITION_TYPE_OVER_UP,
            StackTransitionType::OverDown => ffi::GTK_STACK_TRANSITION_TYPE_OVER_DOWN,
            StackTransitionType::OverLeft => ffi::GTK_STACK_TRANSITION_TYPE_OVER_LEFT,
            StackTransitionType::OverRight => ffi::GTK_STACK_TRANSITION_TYPE_OVER_RIGHT,
            StackTransitionType::UnderUp => ffi::GTK_STACK_TRANSITION_TYPE_UNDER_UP,
            StackTransitionType::UnderDown => ffi::GTK_STACK_TRANSITION_TYPE_UNDER_DOWN,
            StackTransitionType::UnderLeft => ffi::GTK_STACK_TRANSITION_TYPE_UNDER_LEFT,
            StackTransitionType::UnderRight => ffi::GTK_STACK_TRANSITION_TYPE_UNDER_RIGHT,
            StackTransitionType::OverUpDown => ffi::GTK_STACK_TRANSITION_TYPE_OVER_UP_DOWN,
            StackTransitionType::OverDownUp => ffi::GTK_STACK_TRANSITION_TYPE_OVER_DOWN_UP,
            StackTransitionType::OverLeftRight => ffi::GTK_STACK_TRANSITION_TYPE_OVER_LEFT_RIGHT,
            StackTransitionType::OverRightLeft => ffi::GTK_STACK_TRANSITION_TYPE_OVER_RIGHT_LEFT,
            StackTransitionType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkStackTransitionType> for StackTransitionType {
    unsafe fn from_glib(value: ffi::GtkStackTransitionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => StackTransitionType::None,
            1 => StackTransitionType::Crossfade,
            2 => StackTransitionType::SlideRight,
            3 => StackTransitionType::SlideLeft,
            4 => StackTransitionType::SlideUp,
            5 => StackTransitionType::SlideDown,
            6 => StackTransitionType::SlideLeftRight,
            7 => StackTransitionType::SlideUpDown,
            8 => StackTransitionType::OverUp,
            9 => StackTransitionType::OverDown,
            10 => StackTransitionType::OverLeft,
            11 => StackTransitionType::OverRight,
            12 => StackTransitionType::UnderUp,
            13 => StackTransitionType::UnderDown,
            14 => StackTransitionType::UnderLeft,
            15 => StackTransitionType::UnderRight,
            16 => StackTransitionType::OverUpDown,
            17 => StackTransitionType::OverDownUp,
            18 => StackTransitionType::OverLeftRight,
            19 => StackTransitionType::OverRightLeft,
            value => StackTransitionType::__Unknown(value),
        }
    }
}

impl StaticType for StackTransitionType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_stack_transition_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for StackTransitionType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for StackTransitionType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for StackTransitionType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[deprecated]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkStateType")]
pub enum StateType {
    #[doc(alias = "GTK_STATE_NORMAL")]
    Normal,
    #[doc(alias = "GTK_STATE_ACTIVE")]
    Active,
    #[doc(alias = "GTK_STATE_PRELIGHT")]
    Prelight,
    #[doc(alias = "GTK_STATE_SELECTED")]
    Selected,
    #[doc(alias = "GTK_STATE_INSENSITIVE")]
    Insensitive,
    #[doc(alias = "GTK_STATE_INCONSISTENT")]
    Inconsistent,
    #[doc(alias = "GTK_STATE_FOCUSED")]
    Focused,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for StateType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "StateType::{}",
            match *self {
                StateType::Normal => "Normal",
                StateType::Active => "Active",
                StateType::Prelight => "Prelight",
                StateType::Selected => "Selected",
                StateType::Insensitive => "Insensitive",
                StateType::Inconsistent => "Inconsistent",
                StateType::Focused => "Focused",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for StateType {
    type GlibType = ffi::GtkStateType;

    fn to_glib(self) -> ffi::GtkStateType {
        match self {
            StateType::Normal => ffi::GTK_STATE_NORMAL,
            StateType::Active => ffi::GTK_STATE_ACTIVE,
            StateType::Prelight => ffi::GTK_STATE_PRELIGHT,
            StateType::Selected => ffi::GTK_STATE_SELECTED,
            StateType::Insensitive => ffi::GTK_STATE_INSENSITIVE,
            StateType::Inconsistent => ffi::GTK_STATE_INCONSISTENT,
            StateType::Focused => ffi::GTK_STATE_FOCUSED,
            StateType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkStateType> for StateType {
    unsafe fn from_glib(value: ffi::GtkStateType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => StateType::Normal,
            1 => StateType::Active,
            2 => StateType::Prelight,
            3 => StateType::Selected,
            4 => StateType::Insensitive,
            5 => StateType::Inconsistent,
            6 => StateType::Focused,
            value => StateType::__Unknown(value),
        }
    }
}

impl StaticType for StateType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_state_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for StateType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for StateType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for StateType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkTextDirection")]
pub enum TextDirection {
    #[doc(alias = "GTK_TEXT_DIR_NONE")]
    None,
    #[doc(alias = "GTK_TEXT_DIR_LTR")]
    Ltr,
    #[doc(alias = "GTK_TEXT_DIR_RTL")]
    Rtl,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TextDirection {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TextDirection::{}",
            match *self {
                TextDirection::None => "None",
                TextDirection::Ltr => "Ltr",
                TextDirection::Rtl => "Rtl",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TextDirection {
    type GlibType = ffi::GtkTextDirection;

    fn to_glib(self) -> ffi::GtkTextDirection {
        match self {
            TextDirection::None => ffi::GTK_TEXT_DIR_NONE,
            TextDirection::Ltr => ffi::GTK_TEXT_DIR_LTR,
            TextDirection::Rtl => ffi::GTK_TEXT_DIR_RTL,
            TextDirection::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTextDirection> for TextDirection {
    unsafe fn from_glib(value: ffi::GtkTextDirection) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TextDirection::None,
            1 => TextDirection::Ltr,
            2 => TextDirection::Rtl,
            value => TextDirection::__Unknown(value),
        }
    }
}

impl StaticType for TextDirection {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_text_direction_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TextDirection {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TextDirection {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TextDirection {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v3_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_16")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkTextExtendSelection")]
pub enum TextExtendSelection {
    #[doc(alias = "GTK_TEXT_EXTEND_SELECTION_WORD")]
    Word,
    #[doc(alias = "GTK_TEXT_EXTEND_SELECTION_LINE")]
    Line,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v3_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_16")))]
impl fmt::Display for TextExtendSelection {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TextExtendSelection::{}",
            match *self {
                TextExtendSelection::Word => "Word",
                TextExtendSelection::Line => "Line",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v3_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_16")))]
#[doc(hidden)]
impl ToGlib for TextExtendSelection {
    type GlibType = ffi::GtkTextExtendSelection;

    fn to_glib(self) -> ffi::GtkTextExtendSelection {
        match self {
            TextExtendSelection::Word => ffi::GTK_TEXT_EXTEND_SELECTION_WORD,
            TextExtendSelection::Line => ffi::GTK_TEXT_EXTEND_SELECTION_LINE,
            TextExtendSelection::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v3_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_16")))]
#[doc(hidden)]
impl FromGlib<ffi::GtkTextExtendSelection> for TextExtendSelection {
    unsafe fn from_glib(value: ffi::GtkTextExtendSelection) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TextExtendSelection::Word,
            1 => TextExtendSelection::Line,
            value => TextExtendSelection::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v3_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_16")))]
impl StaticType for TextExtendSelection {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_text_extend_selection_get_type()) }
    }
}

#[cfg(any(feature = "v3_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_16")))]
impl<'a> FromValueOptional<'a> for TextExtendSelection {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v3_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_16")))]
impl<'a> FromValue<'a> for TextExtendSelection {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v3_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_16")))]
impl SetValue for TextExtendSelection {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkTextViewLayer")]
pub enum TextViewLayer {
    #[doc(alias = "GTK_TEXT_VIEW_LAYER_BELOW")]
    Below,
    #[doc(alias = "GTK_TEXT_VIEW_LAYER_ABOVE")]
    Above,
    #[doc(alias = "GTK_TEXT_VIEW_LAYER_BELOW_TEXT")]
    BelowText,
    #[doc(alias = "GTK_TEXT_VIEW_LAYER_ABOVE_TEXT")]
    AboveText,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TextViewLayer {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TextViewLayer::{}",
            match *self {
                TextViewLayer::Below => "Below",
                TextViewLayer::Above => "Above",
                TextViewLayer::BelowText => "BelowText",
                TextViewLayer::AboveText => "AboveText",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TextViewLayer {
    type GlibType = ffi::GtkTextViewLayer;

    fn to_glib(self) -> ffi::GtkTextViewLayer {
        match self {
            TextViewLayer::Below => ffi::GTK_TEXT_VIEW_LAYER_BELOW,
            TextViewLayer::Above => ffi::GTK_TEXT_VIEW_LAYER_ABOVE,
            TextViewLayer::BelowText => ffi::GTK_TEXT_VIEW_LAYER_BELOW_TEXT,
            TextViewLayer::AboveText => ffi::GTK_TEXT_VIEW_LAYER_ABOVE_TEXT,
            TextViewLayer::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTextViewLayer> for TextViewLayer {
    unsafe fn from_glib(value: ffi::GtkTextViewLayer) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TextViewLayer::Below,
            1 => TextViewLayer::Above,
            2 => TextViewLayer::BelowText,
            3 => TextViewLayer::AboveText,
            value => TextViewLayer::__Unknown(value),
        }
    }
}

impl StaticType for TextViewLayer {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_text_view_layer_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TextViewLayer {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TextViewLayer {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TextViewLayer {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkTextWindowType")]
pub enum TextWindowType {
    #[doc(alias = "GTK_TEXT_WINDOW_PRIVATE")]
    Private,
    #[doc(alias = "GTK_TEXT_WINDOW_WIDGET")]
    Widget,
    #[doc(alias = "GTK_TEXT_WINDOW_TEXT")]
    Text,
    #[doc(alias = "GTK_TEXT_WINDOW_LEFT")]
    Left,
    #[doc(alias = "GTK_TEXT_WINDOW_RIGHT")]
    Right,
    #[doc(alias = "GTK_TEXT_WINDOW_TOP")]
    Top,
    #[doc(alias = "GTK_TEXT_WINDOW_BOTTOM")]
    Bottom,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TextWindowType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TextWindowType::{}",
            match *self {
                TextWindowType::Private => "Private",
                TextWindowType::Widget => "Widget",
                TextWindowType::Text => "Text",
                TextWindowType::Left => "Left",
                TextWindowType::Right => "Right",
                TextWindowType::Top => "Top",
                TextWindowType::Bottom => "Bottom",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TextWindowType {
    type GlibType = ffi::GtkTextWindowType;

    fn to_glib(self) -> ffi::GtkTextWindowType {
        match self {
            TextWindowType::Private => ffi::GTK_TEXT_WINDOW_PRIVATE,
            TextWindowType::Widget => ffi::GTK_TEXT_WINDOW_WIDGET,
            TextWindowType::Text => ffi::GTK_TEXT_WINDOW_TEXT,
            TextWindowType::Left => ffi::GTK_TEXT_WINDOW_LEFT,
            TextWindowType::Right => ffi::GTK_TEXT_WINDOW_RIGHT,
            TextWindowType::Top => ffi::GTK_TEXT_WINDOW_TOP,
            TextWindowType::Bottom => ffi::GTK_TEXT_WINDOW_BOTTOM,
            TextWindowType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTextWindowType> for TextWindowType {
    unsafe fn from_glib(value: ffi::GtkTextWindowType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TextWindowType::Private,
            1 => TextWindowType::Widget,
            2 => TextWindowType::Text,
            3 => TextWindowType::Left,
            4 => TextWindowType::Right,
            5 => TextWindowType::Top,
            6 => TextWindowType::Bottom,
            value => TextWindowType::__Unknown(value),
        }
    }
}

impl StaticType for TextWindowType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_text_window_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TextWindowType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TextWindowType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TextWindowType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkToolbarStyle")]
pub enum ToolbarStyle {
    #[doc(alias = "GTK_TOOLBAR_ICONS")]
    Icons,
    #[doc(alias = "GTK_TOOLBAR_TEXT")]
    Text,
    #[doc(alias = "GTK_TOOLBAR_BOTH")]
    Both,
    #[doc(alias = "GTK_TOOLBAR_BOTH_HORIZ")]
    BothHoriz,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ToolbarStyle {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ToolbarStyle::{}",
            match *self {
                ToolbarStyle::Icons => "Icons",
                ToolbarStyle::Text => "Text",
                ToolbarStyle::Both => "Both",
                ToolbarStyle::BothHoriz => "BothHoriz",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ToolbarStyle {
    type GlibType = ffi::GtkToolbarStyle;

    fn to_glib(self) -> ffi::GtkToolbarStyle {
        match self {
            ToolbarStyle::Icons => ffi::GTK_TOOLBAR_ICONS,
            ToolbarStyle::Text => ffi::GTK_TOOLBAR_TEXT,
            ToolbarStyle::Both => ffi::GTK_TOOLBAR_BOTH,
            ToolbarStyle::BothHoriz => ffi::GTK_TOOLBAR_BOTH_HORIZ,
            ToolbarStyle::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkToolbarStyle> for ToolbarStyle {
    unsafe fn from_glib(value: ffi::GtkToolbarStyle) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ToolbarStyle::Icons,
            1 => ToolbarStyle::Text,
            2 => ToolbarStyle::Both,
            3 => ToolbarStyle::BothHoriz,
            value => ToolbarStyle::__Unknown(value),
        }
    }
}

impl StaticType for ToolbarStyle {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_toolbar_style_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ToolbarStyle {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ToolbarStyle {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ToolbarStyle {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkTreeViewColumnSizing")]
pub enum TreeViewColumnSizing {
    #[doc(alias = "GTK_TREE_VIEW_COLUMN_GROW_ONLY")]
    GrowOnly,
    #[doc(alias = "GTK_TREE_VIEW_COLUMN_AUTOSIZE")]
    Autosize,
    #[doc(alias = "GTK_TREE_VIEW_COLUMN_FIXED")]
    Fixed,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TreeViewColumnSizing {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TreeViewColumnSizing::{}",
            match *self {
                TreeViewColumnSizing::GrowOnly => "GrowOnly",
                TreeViewColumnSizing::Autosize => "Autosize",
                TreeViewColumnSizing::Fixed => "Fixed",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TreeViewColumnSizing {
    type GlibType = ffi::GtkTreeViewColumnSizing;

    fn to_glib(self) -> ffi::GtkTreeViewColumnSizing {
        match self {
            TreeViewColumnSizing::GrowOnly => ffi::GTK_TREE_VIEW_COLUMN_GROW_ONLY,
            TreeViewColumnSizing::Autosize => ffi::GTK_TREE_VIEW_COLUMN_AUTOSIZE,
            TreeViewColumnSizing::Fixed => ffi::GTK_TREE_VIEW_COLUMN_FIXED,
            TreeViewColumnSizing::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTreeViewColumnSizing> for TreeViewColumnSizing {
    unsafe fn from_glib(value: ffi::GtkTreeViewColumnSizing) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TreeViewColumnSizing::GrowOnly,
            1 => TreeViewColumnSizing::Autosize,
            2 => TreeViewColumnSizing::Fixed,
            value => TreeViewColumnSizing::__Unknown(value),
        }
    }
}

impl StaticType for TreeViewColumnSizing {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_tree_view_column_sizing_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TreeViewColumnSizing {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TreeViewColumnSizing {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TreeViewColumnSizing {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkTreeViewDropPosition")]
pub enum TreeViewDropPosition {
    #[doc(alias = "GTK_TREE_VIEW_DROP_BEFORE")]
    Before,
    #[doc(alias = "GTK_TREE_VIEW_DROP_AFTER")]
    After,
    #[doc(alias = "GTK_TREE_VIEW_DROP_INTO_OR_BEFORE")]
    IntoOrBefore,
    #[doc(alias = "GTK_TREE_VIEW_DROP_INTO_OR_AFTER")]
    IntoOrAfter,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TreeViewDropPosition {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TreeViewDropPosition::{}",
            match *self {
                TreeViewDropPosition::Before => "Before",
                TreeViewDropPosition::After => "After",
                TreeViewDropPosition::IntoOrBefore => "IntoOrBefore",
                TreeViewDropPosition::IntoOrAfter => "IntoOrAfter",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TreeViewDropPosition {
    type GlibType = ffi::GtkTreeViewDropPosition;

    fn to_glib(self) -> ffi::GtkTreeViewDropPosition {
        match self {
            TreeViewDropPosition::Before => ffi::GTK_TREE_VIEW_DROP_BEFORE,
            TreeViewDropPosition::After => ffi::GTK_TREE_VIEW_DROP_AFTER,
            TreeViewDropPosition::IntoOrBefore => ffi::GTK_TREE_VIEW_DROP_INTO_OR_BEFORE,
            TreeViewDropPosition::IntoOrAfter => ffi::GTK_TREE_VIEW_DROP_INTO_OR_AFTER,
            TreeViewDropPosition::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTreeViewDropPosition> for TreeViewDropPosition {
    unsafe fn from_glib(value: ffi::GtkTreeViewDropPosition) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TreeViewDropPosition::Before,
            1 => TreeViewDropPosition::After,
            2 => TreeViewDropPosition::IntoOrBefore,
            3 => TreeViewDropPosition::IntoOrAfter,
            value => TreeViewDropPosition::__Unknown(value),
        }
    }
}

impl StaticType for TreeViewDropPosition {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_tree_view_drop_position_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TreeViewDropPosition {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TreeViewDropPosition {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TreeViewDropPosition {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkTreeViewGridLines")]
pub enum TreeViewGridLines {
    #[doc(alias = "GTK_TREE_VIEW_GRID_LINES_NONE")]
    None,
    #[doc(alias = "GTK_TREE_VIEW_GRID_LINES_HORIZONTAL")]
    Horizontal,
    #[doc(alias = "GTK_TREE_VIEW_GRID_LINES_VERTICAL")]
    Vertical,
    #[doc(alias = "GTK_TREE_VIEW_GRID_LINES_BOTH")]
    Both,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TreeViewGridLines {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TreeViewGridLines::{}",
            match *self {
                TreeViewGridLines::None => "None",
                TreeViewGridLines::Horizontal => "Horizontal",
                TreeViewGridLines::Vertical => "Vertical",
                TreeViewGridLines::Both => "Both",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TreeViewGridLines {
    type GlibType = ffi::GtkTreeViewGridLines;

    fn to_glib(self) -> ffi::GtkTreeViewGridLines {
        match self {
            TreeViewGridLines::None => ffi::GTK_TREE_VIEW_GRID_LINES_NONE,
            TreeViewGridLines::Horizontal => ffi::GTK_TREE_VIEW_GRID_LINES_HORIZONTAL,
            TreeViewGridLines::Vertical => ffi::GTK_TREE_VIEW_GRID_LINES_VERTICAL,
            TreeViewGridLines::Both => ffi::GTK_TREE_VIEW_GRID_LINES_BOTH,
            TreeViewGridLines::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTreeViewGridLines> for TreeViewGridLines {
    unsafe fn from_glib(value: ffi::GtkTreeViewGridLines) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TreeViewGridLines::None,
            1 => TreeViewGridLines::Horizontal,
            2 => TreeViewGridLines::Vertical,
            3 => TreeViewGridLines::Both,
            value => TreeViewGridLines::__Unknown(value),
        }
    }
}

impl StaticType for TreeViewGridLines {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_tree_view_grid_lines_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TreeViewGridLines {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TreeViewGridLines {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TreeViewGridLines {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkUnit")]
pub enum Unit {
    #[doc(alias = "GTK_UNIT_NONE")]
    None,
    #[doc(alias = "GTK_UNIT_POINTS")]
    Points,
    #[doc(alias = "GTK_UNIT_INCH")]
    Inch,
    #[doc(alias = "GTK_UNIT_MM")]
    Mm,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Unit {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Unit::{}",
            match *self {
                Unit::None => "None",
                Unit::Points => "Points",
                Unit::Inch => "Inch",
                Unit::Mm => "Mm",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Unit {
    type GlibType = ffi::GtkUnit;

    fn to_glib(self) -> ffi::GtkUnit {
        match self {
            Unit::None => ffi::GTK_UNIT_NONE,
            Unit::Points => ffi::GTK_UNIT_POINTS,
            Unit::Inch => ffi::GTK_UNIT_INCH,
            Unit::Mm => ffi::GTK_UNIT_MM,
            Unit::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkUnit> for Unit {
    unsafe fn from_glib(value: ffi::GtkUnit) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Unit::None,
            1 => Unit::Points,
            2 => Unit::Inch,
            3 => Unit::Mm,
            value => Unit::__Unknown(value),
        }
    }
}

impl StaticType for Unit {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_unit_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Unit {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Unit {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Unit {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkWidgetHelpType")]
pub enum WidgetHelpType {
    #[doc(alias = "GTK_WIDGET_HELP_TOOLTIP")]
    Tooltip,
    #[doc(alias = "GTK_WIDGET_HELP_WHATS_THIS")]
    WhatsThis,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for WidgetHelpType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "WidgetHelpType::{}",
            match *self {
                WidgetHelpType::Tooltip => "Tooltip",
                WidgetHelpType::WhatsThis => "WhatsThis",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for WidgetHelpType {
    type GlibType = ffi::GtkWidgetHelpType;

    fn to_glib(self) -> ffi::GtkWidgetHelpType {
        match self {
            WidgetHelpType::Tooltip => ffi::GTK_WIDGET_HELP_TOOLTIP,
            WidgetHelpType::WhatsThis => ffi::GTK_WIDGET_HELP_WHATS_THIS,
            WidgetHelpType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkWidgetHelpType> for WidgetHelpType {
    unsafe fn from_glib(value: ffi::GtkWidgetHelpType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WidgetHelpType::Tooltip,
            1 => WidgetHelpType::WhatsThis,
            value => WidgetHelpType::__Unknown(value),
        }
    }
}

impl StaticType for WidgetHelpType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_widget_help_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for WidgetHelpType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for WidgetHelpType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for WidgetHelpType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkWindowPosition")]
pub enum WindowPosition {
    #[doc(alias = "GTK_WIN_POS_NONE")]
    None,
    #[doc(alias = "GTK_WIN_POS_CENTER")]
    Center,
    #[doc(alias = "GTK_WIN_POS_MOUSE")]
    Mouse,
    #[doc(alias = "GTK_WIN_POS_CENTER_ALWAYS")]
    CenterAlways,
    #[doc(alias = "GTK_WIN_POS_CENTER_ON_PARENT")]
    CenterOnParent,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for WindowPosition {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "WindowPosition::{}",
            match *self {
                WindowPosition::None => "None",
                WindowPosition::Center => "Center",
                WindowPosition::Mouse => "Mouse",
                WindowPosition::CenterAlways => "CenterAlways",
                WindowPosition::CenterOnParent => "CenterOnParent",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for WindowPosition {
    type GlibType = ffi::GtkWindowPosition;

    fn to_glib(self) -> ffi::GtkWindowPosition {
        match self {
            WindowPosition::None => ffi::GTK_WIN_POS_NONE,
            WindowPosition::Center => ffi::GTK_WIN_POS_CENTER,
            WindowPosition::Mouse => ffi::GTK_WIN_POS_MOUSE,
            WindowPosition::CenterAlways => ffi::GTK_WIN_POS_CENTER_ALWAYS,
            WindowPosition::CenterOnParent => ffi::GTK_WIN_POS_CENTER_ON_PARENT,
            WindowPosition::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkWindowPosition> for WindowPosition {
    unsafe fn from_glib(value: ffi::GtkWindowPosition) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WindowPosition::None,
            1 => WindowPosition::Center,
            2 => WindowPosition::Mouse,
            3 => WindowPosition::CenterAlways,
            4 => WindowPosition::CenterOnParent,
            value => WindowPosition::__Unknown(value),
        }
    }
}

impl StaticType for WindowPosition {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_window_position_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for WindowPosition {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for WindowPosition {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for WindowPosition {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkWindowType")]
pub enum WindowType {
    #[doc(alias = "GTK_WINDOW_TOPLEVEL")]
    Toplevel,
    #[doc(alias = "GTK_WINDOW_POPUP")]
    Popup,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for WindowType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "WindowType::{}",
            match *self {
                WindowType::Toplevel => "Toplevel",
                WindowType::Popup => "Popup",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for WindowType {
    type GlibType = ffi::GtkWindowType;

    fn to_glib(self) -> ffi::GtkWindowType {
        match self {
            WindowType::Toplevel => ffi::GTK_WINDOW_TOPLEVEL,
            WindowType::Popup => ffi::GTK_WINDOW_POPUP,
            WindowType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkWindowType> for WindowType {
    unsafe fn from_glib(value: ffi::GtkWindowType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WindowType::Toplevel,
            1 => WindowType::Popup,
            value => WindowType::__Unknown(value),
        }
    }
}

impl StaticType for WindowType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_window_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for WindowType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for WindowType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for WindowType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkWrapMode")]
pub enum WrapMode {
    #[doc(alias = "GTK_WRAP_NONE")]
    None,
    #[doc(alias = "GTK_WRAP_CHAR")]
    Char,
    #[doc(alias = "GTK_WRAP_WORD")]
    Word,
    #[doc(alias = "GTK_WRAP_WORD_CHAR")]
    WordChar,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for WrapMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "WrapMode::{}",
            match *self {
                WrapMode::None => "None",
                WrapMode::Char => "Char",
                WrapMode::Word => "Word",
                WrapMode::WordChar => "WordChar",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for WrapMode {
    type GlibType = ffi::GtkWrapMode;

    fn to_glib(self) -> ffi::GtkWrapMode {
        match self {
            WrapMode::None => ffi::GTK_WRAP_NONE,
            WrapMode::Char => ffi::GTK_WRAP_CHAR,
            WrapMode::Word => ffi::GTK_WRAP_WORD,
            WrapMode::WordChar => ffi::GTK_WRAP_WORD_CHAR,
            WrapMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkWrapMode> for WrapMode {
    unsafe fn from_glib(value: ffi::GtkWrapMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WrapMode::None,
            1 => WrapMode::Char,
            2 => WrapMode::Word,
            3 => WrapMode::WordChar,
            value => WrapMode::__Unknown(value),
        }
    }
}

impl StaticType for WrapMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_wrap_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for WrapMode {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for WrapMode {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for WrapMode {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}
