// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(
    clippy::approx_constant,
    clippy::type_complexity,
    clippy::unreadable_literal,
    clippy::upper_case_acronyms
)]
#![cfg_attr(docsrs, feature(doc_cfg))]

use glib_sys as glib;

#[allow(unused_imports)]
use libc::{
    c_char, c_double, c_float, c_int, c_long, c_short, c_uchar, c_uint, c_ulong, c_ushort, c_void,
    intptr_t, size_t, ssize_t, uintptr_t, FILE,
};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

pub const G_TYPE_INVALID: GType = 0 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_NONE: GType = 1 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_INTERFACE: GType = 2 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_CHAR: GType = 3 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_UCHAR: GType = 4 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_BOOLEAN: GType = 5 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_INT: GType = 6 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_UINT: GType = 7 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_LONG: GType = 8 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_ULONG: GType = 9 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_INT64: GType = 10 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_UINT64: GType = 11 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_ENUM: GType = 12 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_FLAGS: GType = 13 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_FLOAT: GType = 14 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_DOUBLE: GType = 15 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_STRING: GType = 16 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_POINTER: GType = 17 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_BOXED: GType = 18 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_PARAM: GType = 19 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_OBJECT: GType = 20 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_VARIANT: GType = 21 << G_TYPE_FUNDAMENTAL_SHIFT;

// Aliases
pub type GSignalCMarshaller = GClosureMarshal;

// Constants
pub const G_PARAM_MASK: c_int = 255;
pub const G_PARAM_STATIC_STRINGS: c_int = 224;
pub const G_PARAM_USER_SHIFT: c_int = 8;
pub const G_SIGNAL_FLAGS_MASK: c_int = 511;
pub const G_SIGNAL_MATCH_MASK: c_int = 63;
pub const G_TYPE_FLAG_RESERVED_ID_BIT: GType = 1;
pub const G_TYPE_FUNDAMENTAL_MAX: c_int = 1020;
pub const G_TYPE_FUNDAMENTAL_SHIFT: c_int = 2;
pub const G_TYPE_RESERVED_BSE_FIRST: c_int = 32;
pub const G_TYPE_RESERVED_BSE_LAST: c_int = 48;
pub const G_TYPE_RESERVED_GLIB_FIRST: c_int = 22;
pub const G_TYPE_RESERVED_GLIB_LAST: c_int = 31;
pub const G_TYPE_RESERVED_USER_FIRST: c_int = 49;
pub const G_VALUE_COLLECT_FORMAT_MAX_LENGTH: c_int = 8;
pub const G_VALUE_INTERNED_STRING: c_int = 268435456;
pub const G_VALUE_NOCOPY_CONTENTS: c_int = 134217728;

// Flags
pub type GBindingFlags = c_uint;
pub const G_BINDING_DEFAULT: GBindingFlags = 0;
pub const G_BINDING_BIDIRECTIONAL: GBindingFlags = 1;
pub const G_BINDING_SYNC_CREATE: GBindingFlags = 2;
pub const G_BINDING_INVERT_BOOLEAN: GBindingFlags = 4;

pub type GConnectFlags = c_uint;
pub const G_CONNECT_DEFAULT: GConnectFlags = 0;
pub const G_CONNECT_AFTER: GConnectFlags = 1;
pub const G_CONNECT_SWAPPED: GConnectFlags = 2;

pub type GIOCondition = c_uint;
pub const G_IO_IN: GIOCondition = 1;
pub const G_IO_OUT: GIOCondition = 4;
pub const G_IO_PRI: GIOCondition = 2;
pub const G_IO_ERR: GIOCondition = 8;
pub const G_IO_HUP: GIOCondition = 16;
pub const G_IO_NVAL: GIOCondition = 32;

pub type GParamFlags = c_uint;
pub const G_PARAM_READABLE: GParamFlags = 1;
pub const G_PARAM_WRITABLE: GParamFlags = 2;
pub const G_PARAM_READWRITE: GParamFlags = 3;
pub const G_PARAM_CONSTRUCT: GParamFlags = 4;
pub const G_PARAM_CONSTRUCT_ONLY: GParamFlags = 8;
pub const G_PARAM_LAX_VALIDATION: GParamFlags = 16;
pub const G_PARAM_STATIC_NAME: GParamFlags = 32;
pub const G_PARAM_PRIVATE: GParamFlags = 32;
pub const G_PARAM_STATIC_NICK: GParamFlags = 64;
pub const G_PARAM_STATIC_BLURB: GParamFlags = 128;
pub const G_PARAM_EXPLICIT_NOTIFY: GParamFlags = 1073741824;
pub const G_PARAM_DEPRECATED: GParamFlags = 2147483648;

pub type GSignalFlags = c_uint;
pub const G_SIGNAL_RUN_FIRST: GSignalFlags = 1;
pub const G_SIGNAL_RUN_LAST: GSignalFlags = 2;
pub const G_SIGNAL_RUN_CLEANUP: GSignalFlags = 4;
pub const G_SIGNAL_NO_RECURSE: GSignalFlags = 8;
pub const G_SIGNAL_DETAILED: GSignalFlags = 16;
pub const G_SIGNAL_ACTION: GSignalFlags = 32;
pub const G_SIGNAL_NO_HOOKS: GSignalFlags = 64;
pub const G_SIGNAL_MUST_COLLECT: GSignalFlags = 128;
pub const G_SIGNAL_DEPRECATED: GSignalFlags = 256;
pub const G_SIGNAL_ACCUMULATOR_FIRST_RUN: GSignalFlags = 131072;

pub type GSignalMatchType = c_uint;
pub const G_SIGNAL_MATCH_ID: GSignalMatchType = 1;
pub const G_SIGNAL_MATCH_DETAIL: GSignalMatchType = 2;
pub const G_SIGNAL_MATCH_CLOSURE: GSignalMatchType = 4;
pub const G_SIGNAL_MATCH_FUNC: GSignalMatchType = 8;
pub const G_SIGNAL_MATCH_DATA: GSignalMatchType = 16;
pub const G_SIGNAL_MATCH_UNBLOCKED: GSignalMatchType = 32;

pub type GTypeDebugFlags = c_uint;
pub const G_TYPE_DEBUG_NONE: GTypeDebugFlags = 0;
pub const G_TYPE_DEBUG_OBJECTS: GTypeDebugFlags = 1;
pub const G_TYPE_DEBUG_SIGNALS: GTypeDebugFlags = 2;
pub const G_TYPE_DEBUG_INSTANCE_COUNT: GTypeDebugFlags = 4;
pub const G_TYPE_DEBUG_MASK: GTypeDebugFlags = 7;

pub type GTypeFlags = c_uint;
pub const G_TYPE_FLAG_NONE: GTypeFlags = 0;
pub const G_TYPE_FLAG_ABSTRACT: GTypeFlags = 16;
pub const G_TYPE_FLAG_VALUE_ABSTRACT: GTypeFlags = 32;
pub const G_TYPE_FLAG_FINAL: GTypeFlags = 64;
pub const G_TYPE_FLAG_DEPRECATED: GTypeFlags = 128;

pub type GTypeFundamentalFlags = c_uint;
pub const G_TYPE_FLAG_CLASSED: GTypeFundamentalFlags = 1;
pub const G_TYPE_FLAG_INSTANTIATABLE: GTypeFundamentalFlags = 2;
pub const G_TYPE_FLAG_DERIVABLE: GTypeFundamentalFlags = 4;
pub const G_TYPE_FLAG_DEEP_DERIVABLE: GTypeFundamentalFlags = 8;

// Unions
#[derive(Copy, Clone)]
#[repr(C)]
pub union GTypeCValue {
    pub v_int: c_int,
    pub v_long: c_long,
    pub v_int64: i64,
    pub v_double: c_double,
    pub v_pointer: gpointer,
}

impl ::std::fmt::Debug for GTypeCValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GTypeCValue @ {self:p}"))
            .field("v_int", unsafe { &self.v_int })
            .field("v_long", unsafe { &self.v_long })
            .field("v_int64", unsafe { &self.v_int64 })
            .field("v_double", unsafe { &self.v_double })
            .field("v_pointer", unsafe { &self.v_pointer })
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub union GValue_data {
    pub v_int: c_int,
    pub v_uint: c_uint,
    pub v_long: c_long,
    pub v_ulong: c_ulong,
    pub v_int64: i64,
    pub v_uint64: u64,
    pub v_float: c_float,
    pub v_double: c_double,
    pub v_pointer: gpointer,
}

impl ::std::fmt::Debug for GValue_data {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GValue_data @ {self:p}"))
            .field("v_int", unsafe { &self.v_int })
            .field("v_uint", unsafe { &self.v_uint })
            .field("v_long", unsafe { &self.v_long })
            .field("v_ulong", unsafe { &self.v_ulong })
            .field("v_int64", unsafe { &self.v_int64 })
            .field("v_uint64", unsafe { &self.v_uint64 })
            .field("v_float", unsafe { &self.v_float })
            .field("v_double", unsafe { &self.v_double })
            .field("v_pointer", unsafe { &self.v_pointer })
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub union GWeakRef_priv {
    pub p: gpointer,
}

impl ::std::fmt::Debug for GWeakRef_priv {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GWeakRef_priv @ {self:p}"))
            .field("p", unsafe { &self.p })
            .finish()
    }
}

// Callbacks
pub type GBaseFinalizeFunc = Option<unsafe extern "C" fn(gpointer)>;
pub type GBaseInitFunc = Option<unsafe extern "C" fn(gpointer)>;
pub type GBindingTransformFunc =
    Option<unsafe extern "C" fn(*mut GBinding, *const GValue, *mut GValue, gpointer) -> gboolean>;
pub type GBoxedCopyFunc = Option<unsafe extern "C" fn(gpointer) -> gpointer>;
pub type GBoxedFreeFunc = Option<unsafe extern "C" fn(gpointer)>;
pub type GCallback = Option<unsafe extern "C" fn()>;
pub type GClassFinalizeFunc = Option<unsafe extern "C" fn(gpointer, gpointer)>;
pub type GClassInitFunc = Option<unsafe extern "C" fn(gpointer, gpointer)>;
pub type GClosureMarshal = Option<
    unsafe extern "C" fn(*mut GClosure, *mut GValue, c_uint, *const GValue, gpointer, gpointer),
>;
pub type GClosureNotify = Option<unsafe extern "C" fn(gpointer, *mut GClosure)>;
pub type GInstanceInitFunc = Option<unsafe extern "C" fn(*mut GTypeInstance, gpointer)>;
pub type GInterfaceFinalizeFunc = Option<unsafe extern "C" fn(gpointer, gpointer)>;
pub type GInterfaceInitFunc = Option<unsafe extern "C" fn(gpointer, gpointer)>;
pub type GObjectFinalizeFunc = Option<unsafe extern "C" fn(*mut GObject)>;
pub type GObjectGetPropertyFunc =
    Option<unsafe extern "C" fn(*mut GObject, c_uint, *mut GValue, *mut GParamSpec)>;
pub type GObjectSetPropertyFunc =
    Option<unsafe extern "C" fn(*mut GObject, c_uint, *const GValue, *mut GParamSpec)>;
pub type GSignalAccumulator = Option<
    unsafe extern "C" fn(
        *mut GSignalInvocationHint,
        *mut GValue,
        *const GValue,
        gpointer,
    ) -> gboolean,
>;
pub type GSignalEmissionHook = Option<
    unsafe extern "C" fn(*mut GSignalInvocationHint, c_uint, *const GValue, gpointer) -> gboolean,
>;
pub type GToggleNotify = Option<unsafe extern "C" fn(gpointer, *mut GObject, gboolean)>;
pub type GTypeClassCacheFunc = Option<unsafe extern "C" fn(gpointer, *mut GTypeClass) -> gboolean>;
pub type GTypeInterfaceCheckFunc = Option<unsafe extern "C" fn(gpointer, gpointer)>;
pub type GTypePluginCompleteInterfaceInfo =
    Option<unsafe extern "C" fn(*mut GTypePlugin, GType, GType, *mut GInterfaceInfo)>;
pub type GTypePluginCompleteTypeInfo =
    Option<unsafe extern "C" fn(*mut GTypePlugin, GType, *mut GTypeInfo, *mut GTypeValueTable)>;
pub type GTypePluginUnuse = Option<unsafe extern "C" fn(*mut GTypePlugin)>;
pub type GTypePluginUse = Option<unsafe extern "C" fn(*mut GTypePlugin)>;
pub type GTypeValueCollectFunc =
    Option<unsafe extern "C" fn(*mut GValue, c_uint, *mut GTypeCValue, c_uint) -> *mut c_char>;
pub type GTypeValueCopyFunc = Option<unsafe extern "C" fn(*const GValue, *mut GValue)>;
pub type GTypeValueFreeFunc = Option<unsafe extern "C" fn(*mut GValue)>;
pub type GTypeValueInitFunc = Option<unsafe extern "C" fn(*mut GValue)>;
pub type GTypeValueLCopyFunc =
    Option<unsafe extern "C" fn(*const GValue, c_uint, *mut GTypeCValue, c_uint) -> *mut c_char>;
pub type GTypeValuePeekPointerFunc = Option<unsafe extern "C" fn(*const GValue) -> gpointer>;
//pub type GVaClosureMarshal = Option<unsafe extern "C" fn(*mut GClosure, *mut GValue, gpointer, /*Unimplemented*/va_list, gpointer, c_int, *mut GType)>;
pub type GValueTransform = Option<unsafe extern "C" fn(*const GValue, *mut GValue)>;
pub type GWeakNotify = Option<unsafe extern "C" fn(gpointer, *mut GObject)>;

// Records
#[repr(C)]
pub struct GCClosure {
    _truncated_record_marker: c_void,
    // /*Ignored*/field closure has incomplete type
}

impl ::std::fmt::Debug for GCClosure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GCClosure @ {self:p}")).finish()
    }
}

#[repr(C)]
pub struct GClosure {
    pub ref_count: c_uint,
    _truncated_record_marker: c_void,
    // field meta_marshal_nouse has incomplete type
}

impl ::std::fmt::Debug for GClosure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GClosure @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GClosureNotifyData {
    pub data: gpointer,
    pub notify: GClosureNotify,
}

impl ::std::fmt::Debug for GClosureNotifyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GClosureNotifyData @ {self:p}"))
            .field("data", &self.data)
            .field("notify", &self.notify)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GEnumClass {
    pub g_type_class: GTypeClass,
    pub minimum: c_int,
    pub maximum: c_int,
    pub n_values: c_uint,
    pub values: *mut GEnumValue,
}

impl ::std::fmt::Debug for GEnumClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GEnumClass @ {self:p}"))
            .field("g_type_class", &self.g_type_class)
            .field("minimum", &self.minimum)
            .field("maximum", &self.maximum)
            .field("n_values", &self.n_values)
            .field("values", &self.values)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GEnumValue {
    pub value: c_int,
    pub value_name: *const c_char,
    pub value_nick: *const c_char,
}

impl ::std::fmt::Debug for GEnumValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GEnumValue @ {self:p}"))
            .field("value", &self.value)
            .field("value_name", &self.value_name)
            .field("value_nick", &self.value_nick)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GFlagsClass {
    pub g_type_class: GTypeClass,
    pub mask: c_uint,
    pub n_values: c_uint,
    pub values: *mut GFlagsValue,
}

impl ::std::fmt::Debug for GFlagsClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GFlagsClass @ {self:p}"))
            .field("g_type_class", &self.g_type_class)
            .field("mask", &self.mask)
            .field("n_values", &self.n_values)
            .field("values", &self.values)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GFlagsValue {
    pub value: c_uint,
    pub value_name: *const c_char,
    pub value_nick: *const c_char,
}

impl ::std::fmt::Debug for GFlagsValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GFlagsValue @ {self:p}"))
            .field("value", &self.value)
            .field("value_name", &self.value_name)
            .field("value_nick", &self.value_nick)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GInitiallyUnownedClass {
    pub g_type_class: GTypeClass,
    pub construct_properties: *mut glib::GSList,
    pub constructor:
        Option<unsafe extern "C" fn(GType, c_uint, *mut GObjectConstructParam) -> *mut GObject>,
    pub set_property:
        Option<unsafe extern "C" fn(*mut GObject, c_uint, *mut GValue, *mut GParamSpec)>,
    pub get_property:
        Option<unsafe extern "C" fn(*mut GObject, c_uint, *mut GValue, *mut GParamSpec)>,
    pub dispose: Option<unsafe extern "C" fn(*mut GObject)>,
    pub finalize: Option<unsafe extern "C" fn(*mut GObject)>,
    pub dispatch_properties_changed:
        Option<unsafe extern "C" fn(*mut GObject, c_uint, *mut *mut GParamSpec)>,
    pub notify: Option<unsafe extern "C" fn(*mut GObject, *mut GParamSpec)>,
    pub constructed: Option<unsafe extern "C" fn(*mut GObject)>,
    pub flags: size_t,
    pub n_construct_properties: size_t,
    pub pspecs: gpointer,
    pub n_pspecs: size_t,
    pub pdummy: [gpointer; 3],
}

impl ::std::fmt::Debug for GInitiallyUnownedClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GInitiallyUnownedClass @ {self:p}"))
            .field("g_type_class", &self.g_type_class)
            .field("constructor", &self.constructor)
            .field("set_property", &self.set_property)
            .field("get_property", &self.get_property)
            .field("dispose", &self.dispose)
            .field("finalize", &self.finalize)
            .field(
                "dispatch_properties_changed",
                &self.dispatch_properties_changed,
            )
            .field("notify", &self.notify)
            .field("constructed", &self.constructed)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GInterfaceInfo {
    pub interface_init: GInterfaceInitFunc,
    pub interface_finalize: GInterfaceFinalizeFunc,
    pub interface_data: gpointer,
}

impl ::std::fmt::Debug for GInterfaceInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GInterfaceInfo @ {self:p}"))
            .field("interface_init", &self.interface_init)
            .field("interface_finalize", &self.interface_finalize)
            .field("interface_data", &self.interface_data)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GObjectClass {
    pub g_type_class: GTypeClass,
    pub construct_properties: *mut glib::GSList,
    pub constructor:
        Option<unsafe extern "C" fn(GType, c_uint, *mut GObjectConstructParam) -> *mut GObject>,
    pub set_property:
        Option<unsafe extern "C" fn(*mut GObject, c_uint, *mut GValue, *mut GParamSpec)>,
    pub get_property:
        Option<unsafe extern "C" fn(*mut GObject, c_uint, *mut GValue, *mut GParamSpec)>,
    pub dispose: Option<unsafe extern "C" fn(*mut GObject)>,
    pub finalize: Option<unsafe extern "C" fn(*mut GObject)>,
    pub dispatch_properties_changed:
        Option<unsafe extern "C" fn(*mut GObject, c_uint, *mut *mut GParamSpec)>,
    pub notify: Option<unsafe extern "C" fn(*mut GObject, *mut GParamSpec)>,
    pub constructed: Option<unsafe extern "C" fn(*mut GObject)>,
    pub flags: size_t,
    pub n_construct_properties: size_t,
    pub pspecs: gpointer,
    pub n_pspecs: size_t,
    pub pdummy: [gpointer; 3],
}

impl ::std::fmt::Debug for GObjectClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GObjectClass @ {self:p}"))
            .field("g_type_class", &self.g_type_class)
            .field("constructor", &self.constructor)
            .field("set_property", &self.set_property)
            .field("get_property", &self.get_property)
            .field("dispose", &self.dispose)
            .field("finalize", &self.finalize)
            .field(
                "dispatch_properties_changed",
                &self.dispatch_properties_changed,
            )
            .field("notify", &self.notify)
            .field("constructed", &self.constructed)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GObjectConstructParam {
    pub pspec: *mut GParamSpec,
    pub value: *mut GValue,
}

impl ::std::fmt::Debug for GObjectConstructParam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GObjectConstructParam @ {self:p}"))
            .field("pspec", &self.pspec)
            .field("value", &self.value)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecClass {
    pub g_type_class: GTypeClass,
    pub value_type: GType,
    pub finalize: Option<unsafe extern "C" fn(*mut GParamSpec)>,
    pub value_set_default: Option<unsafe extern "C" fn(*mut GParamSpec, *mut GValue)>,
    pub value_validate: Option<unsafe extern "C" fn(*mut GParamSpec, *mut GValue) -> gboolean>,
    pub values_cmp:
        Option<unsafe extern "C" fn(*mut GParamSpec, *const GValue, *const GValue) -> c_int>,
    pub value_is_valid: Option<unsafe extern "C" fn(*mut GParamSpec, *mut GValue) -> gboolean>,
    pub dummy: [gpointer; 3],
}

impl ::std::fmt::Debug for GParamSpecClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecClass @ {self:p}"))
            .field("g_type_class", &self.g_type_class)
            .field("value_type", &self.value_type)
            .field("finalize", &self.finalize)
            .field("value_set_default", &self.value_set_default)
            .field("value_validate", &self.value_validate)
            .field("values_cmp", &self.values_cmp)
            .field("value_is_valid", &self.value_is_valid)
            .finish()
    }
}

#[repr(C)]
pub struct _GParamSpecPool {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GParamSpecPool = _GParamSpecPool;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecTypeInfo {
    pub instance_size: u16,
    pub n_preallocs: u16,
    pub instance_init: Option<unsafe extern "C" fn(*mut GParamSpec)>,
    pub value_type: GType,
    pub finalize: Option<unsafe extern "C" fn(*mut GParamSpec)>,
    pub value_set_default: Option<unsafe extern "C" fn(*mut GParamSpec, *mut GValue)>,
    pub value_validate: Option<unsafe extern "C" fn(*mut GParamSpec, *mut GValue) -> gboolean>,
    pub values_cmp:
        Option<unsafe extern "C" fn(*mut GParamSpec, *const GValue, *const GValue) -> c_int>,
}

impl ::std::fmt::Debug for GParamSpecTypeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecTypeInfo @ {self:p}"))
            .field("instance_size", &self.instance_size)
            .field("n_preallocs", &self.n_preallocs)
            .field("instance_init", &self.instance_init)
            .field("value_type", &self.value_type)
            .field("finalize", &self.finalize)
            .field("value_set_default", &self.value_set_default)
            .field("value_validate", &self.value_validate)
            .field("values_cmp", &self.values_cmp)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParameter {
    pub name: *const c_char,
    pub value: GValue,
}

impl ::std::fmt::Debug for GParameter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParameter @ {self:p}"))
            .field("name", &self.name)
            .field("value", &self.value)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GSignalInvocationHint {
    pub signal_id: c_uint,
    pub detail: glib::GQuark,
    pub run_type: GSignalFlags,
}

impl ::std::fmt::Debug for GSignalInvocationHint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GSignalInvocationHint @ {self:p}"))
            .field("signal_id", &self.signal_id)
            .field("detail", &self.detail)
            .field("run_type", &self.run_type)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GSignalQuery {
    pub signal_id: c_uint,
    pub signal_name: *const c_char,
    pub itype: GType,
    pub signal_flags: GSignalFlags,
    pub return_type: GType,
    pub n_params: c_uint,
    pub param_types: *const GType,
}

impl ::std::fmt::Debug for GSignalQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GSignalQuery @ {self:p}"))
            .field("signal_id", &self.signal_id)
            .field("signal_name", &self.signal_name)
            .field("itype", &self.itype)
            .field("signal_flags", &self.signal_flags)
            .field("return_type", &self.return_type)
            .field("n_params", &self.n_params)
            .field("param_types", &self.param_types)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GTypeClass {
    pub g_type: GType,
}

impl ::std::fmt::Debug for GTypeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GTypeClass @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GTypeFundamentalInfo {
    pub type_flags: GTypeFundamentalFlags,
}

impl ::std::fmt::Debug for GTypeFundamentalInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GTypeFundamentalInfo @ {self:p}"))
            .field("type_flags", &self.type_flags)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GTypeInfo {
    pub class_size: u16,
    pub base_init: GBaseInitFunc,
    pub base_finalize: GBaseFinalizeFunc,
    pub class_init: GClassInitFunc,
    pub class_finalize: GClassFinalizeFunc,
    pub class_data: gconstpointer,
    pub instance_size: u16,
    pub n_preallocs: u16,
    pub instance_init: GInstanceInitFunc,
    pub value_table: *const GTypeValueTable,
}

impl ::std::fmt::Debug for GTypeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GTypeInfo @ {self:p}"))
            .field("class_size", &self.class_size)
            .field("base_init", &self.base_init)
            .field("base_finalize", &self.base_finalize)
            .field("class_init", &self.class_init)
            .field("class_finalize", &self.class_finalize)
            .field("class_data", &self.class_data)
            .field("instance_size", &self.instance_size)
            .field("n_preallocs", &self.n_preallocs)
            .field("instance_init", &self.instance_init)
            .field("value_table", &self.value_table)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GTypeInstance {
    pub g_class: *mut GTypeClass,
}

impl ::std::fmt::Debug for GTypeInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GTypeInstance @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GTypeInterface {
    pub g_type: GType,
    pub g_instance_type: GType,
}

impl ::std::fmt::Debug for GTypeInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GTypeInterface @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GTypeModuleClass {
    pub parent_class: GObjectClass,
    pub load: Option<unsafe extern "C" fn(*mut GTypeModule) -> gboolean>,
    pub unload: Option<unsafe extern "C" fn(*mut GTypeModule)>,
    pub reserved1: Option<unsafe extern "C" fn()>,
    pub reserved2: Option<unsafe extern "C" fn()>,
    pub reserved3: Option<unsafe extern "C" fn()>,
    pub reserved4: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for GTypeModuleClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GTypeModuleClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("load", &self.load)
            .field("unload", &self.unload)
            .field("reserved1", &self.reserved1)
            .field("reserved2", &self.reserved2)
            .field("reserved3", &self.reserved3)
            .field("reserved4", &self.reserved4)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GTypePluginClass {
    pub base_iface: GTypeInterface,
    pub use_plugin: GTypePluginUse,
    pub unuse_plugin: GTypePluginUnuse,
    pub complete_type_info: GTypePluginCompleteTypeInfo,
    pub complete_interface_info: GTypePluginCompleteInterfaceInfo,
}

impl ::std::fmt::Debug for GTypePluginClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GTypePluginClass @ {self:p}"))
            .field("use_plugin", &self.use_plugin)
            .field("unuse_plugin", &self.unuse_plugin)
            .field("complete_type_info", &self.complete_type_info)
            .field("complete_interface_info", &self.complete_interface_info)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GTypeQuery {
    pub type_: GType,
    pub type_name: *const c_char,
    pub class_size: c_uint,
    pub instance_size: c_uint,
}

impl ::std::fmt::Debug for GTypeQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GTypeQuery @ {self:p}"))
            .field("type_", &self.type_)
            .field("type_name", &self.type_name)
            .field("class_size", &self.class_size)
            .field("instance_size", &self.instance_size)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GTypeValueTable {
    pub value_init: GTypeValueInitFunc,
    pub value_free: GTypeValueFreeFunc,
    pub value_copy: GTypeValueCopyFunc,
    pub value_peek_pointer: GTypeValuePeekPointerFunc,
    pub collect_format: *const c_char,
    pub collect_value: GTypeValueCollectFunc,
    pub lcopy_format: *const c_char,
    pub lcopy_value: GTypeValueLCopyFunc,
}

impl ::std::fmt::Debug for GTypeValueTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GTypeValueTable @ {self:p}"))
            .field("value_init", &self.value_init)
            .field("value_free", &self.value_free)
            .field("value_copy", &self.value_copy)
            .field("value_peek_pointer", &self.value_peek_pointer)
            .field("collect_format", &self.collect_format)
            .field("collect_value", &self.collect_value)
            .field("lcopy_format", &self.lcopy_format)
            .field("lcopy_value", &self.lcopy_value)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GValue {
    pub g_type: GType,
    pub data: [GValue_data; 2],
}

impl ::std::fmt::Debug for GValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GValue @ {self:p}"))
            .field("data", &self.data)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GValueArray {
    pub n_values: c_uint,
    pub values: *mut GValue,
    pub n_prealloced: c_uint,
}

impl ::std::fmt::Debug for GValueArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GValueArray @ {self:p}"))
            .field("n_values", &self.n_values)
            .field("values", &self.values)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GWeakRef {
    pub priv_: GWeakRef_priv,
}

impl ::std::fmt::Debug for GWeakRef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GWeakRef @ {self:p}"))
            .field("priv_", &self.priv_)
            .finish()
    }
}

// Classes
#[repr(C)]
pub struct GBinding {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GBinding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GBinding @ {self:p}")).finish()
    }
}

#[repr(C)]
pub struct GBindingGroup {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GBindingGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GBindingGroup @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GInitiallyUnowned {
    pub g_type_instance: GTypeInstance,
    pub ref_count: c_uint,
    pub qdata: *mut glib::GData,
}

impl ::std::fmt::Debug for GInitiallyUnowned {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GInitiallyUnowned @ {self:p}"))
            .field("g_type_instance", &self.g_type_instance)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GObject {
    pub g_type_instance: GTypeInstance,
    pub ref_count: c_uint,
    pub qdata: *mut glib::GData,
}

impl ::std::fmt::Debug for GObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GObject @ {self:p}"))
            .field("g_type_instance", &self.g_type_instance)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpec {
    pub g_type_instance: GTypeInstance,
    pub name: *const c_char,
    pub flags: GParamFlags,
    pub value_type: GType,
    pub owner_type: GType,
    pub _nick: *mut c_char,
    pub _blurb: *mut c_char,
    pub qdata: *mut glib::GData,
    pub ref_count: c_uint,
    pub param_id: c_uint,
}

impl ::std::fmt::Debug for GParamSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpec @ {self:p}"))
            .field("g_type_instance", &self.g_type_instance)
            .field("name", &self.name)
            .field("flags", &self.flags)
            .field("value_type", &self.value_type)
            .field("owner_type", &self.owner_type)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecBoolean {
    pub parent_instance: GParamSpec,
    pub default_value: gboolean,
}

impl ::std::fmt::Debug for GParamSpecBoolean {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecBoolean @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("default_value", &self.default_value)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecBoxed {
    pub parent_instance: GParamSpec,
}

impl ::std::fmt::Debug for GParamSpecBoxed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecBoxed @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecChar {
    pub parent_instance: GParamSpec,
    pub minimum: i8,
    pub maximum: i8,
    pub default_value: i8,
}

impl ::std::fmt::Debug for GParamSpecChar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecChar @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("minimum", &self.minimum)
            .field("maximum", &self.maximum)
            .field("default_value", &self.default_value)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecDouble {
    pub parent_instance: GParamSpec,
    pub minimum: c_double,
    pub maximum: c_double,
    pub default_value: c_double,
    pub epsilon: c_double,
}

impl ::std::fmt::Debug for GParamSpecDouble {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecDouble @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("minimum", &self.minimum)
            .field("maximum", &self.maximum)
            .field("default_value", &self.default_value)
            .field("epsilon", &self.epsilon)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecEnum {
    pub parent_instance: GParamSpec,
    pub enum_class: *mut GEnumClass,
    pub default_value: c_int,
}

impl ::std::fmt::Debug for GParamSpecEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecEnum @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("enum_class", &self.enum_class)
            .field("default_value", &self.default_value)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecFlags {
    pub parent_instance: GParamSpec,
    pub flags_class: *mut GFlagsClass,
    pub default_value: c_uint,
}

impl ::std::fmt::Debug for GParamSpecFlags {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecFlags @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("flags_class", &self.flags_class)
            .field("default_value", &self.default_value)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecFloat {
    pub parent_instance: GParamSpec,
    pub minimum: c_float,
    pub maximum: c_float,
    pub default_value: c_float,
    pub epsilon: c_float,
}

impl ::std::fmt::Debug for GParamSpecFloat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecFloat @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("minimum", &self.minimum)
            .field("maximum", &self.maximum)
            .field("default_value", &self.default_value)
            .field("epsilon", &self.epsilon)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecGType {
    pub parent_instance: GParamSpec,
    pub is_a_type: GType,
}

impl ::std::fmt::Debug for GParamSpecGType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecGType @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("is_a_type", &self.is_a_type)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecInt {
    pub parent_instance: GParamSpec,
    pub minimum: c_int,
    pub maximum: c_int,
    pub default_value: c_int,
}

impl ::std::fmt::Debug for GParamSpecInt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecInt @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("minimum", &self.minimum)
            .field("maximum", &self.maximum)
            .field("default_value", &self.default_value)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: i64,
    pub maximum: i64,
    pub default_value: i64,
}

impl ::std::fmt::Debug for GParamSpecInt64 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecInt64 @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("minimum", &self.minimum)
            .field("maximum", &self.maximum)
            .field("default_value", &self.default_value)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecLong {
    pub parent_instance: GParamSpec,
    pub minimum: c_long,
    pub maximum: c_long,
    pub default_value: c_long,
}

impl ::std::fmt::Debug for GParamSpecLong {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecLong @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("minimum", &self.minimum)
            .field("maximum", &self.maximum)
            .field("default_value", &self.default_value)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecObject {
    pub parent_instance: GParamSpec,
}

impl ::std::fmt::Debug for GParamSpecObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecObject @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecOverride {
    pub parent_instance: GParamSpec,
    pub overridden: *mut GParamSpec,
}

impl ::std::fmt::Debug for GParamSpecOverride {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecOverride @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecParam {
    pub parent_instance: GParamSpec,
}

impl ::std::fmt::Debug for GParamSpecParam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecParam @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecPointer {
    pub parent_instance: GParamSpec,
}

impl ::std::fmt::Debug for GParamSpecPointer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecPointer @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
pub struct GParamSpecString {
    pub parent_instance: GParamSpec,
    pub default_value: *mut c_char,
    pub cset_first: *mut c_char,
    pub cset_nth: *mut c_char,
    pub substitutor: c_char,
    pub null_fold_if_empty: c_uint,
    _truncated_record_marker: c_void,
    // field ensure_non_null has incomplete type
}

impl ::std::fmt::Debug for GParamSpecString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecString @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("default_value", &self.default_value)
            .field("cset_first", &self.cset_first)
            .field("cset_nth", &self.cset_nth)
            .field("substitutor", &self.substitutor)
            .field("null_fold_if_empty", &self.null_fold_if_empty)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecUChar {
    pub parent_instance: GParamSpec,
    pub minimum: u8,
    pub maximum: u8,
    pub default_value: u8,
}

impl ::std::fmt::Debug for GParamSpecUChar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecUChar @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("minimum", &self.minimum)
            .field("maximum", &self.maximum)
            .field("default_value", &self.default_value)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecUInt {
    pub parent_instance: GParamSpec,
    pub minimum: c_uint,
    pub maximum: c_uint,
    pub default_value: c_uint,
}

impl ::std::fmt::Debug for GParamSpecUInt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecUInt @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("minimum", &self.minimum)
            .field("maximum", &self.maximum)
            .field("default_value", &self.default_value)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecUInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: u64,
    pub maximum: u64,
    pub default_value: u64,
}

impl ::std::fmt::Debug for GParamSpecUInt64 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecUInt64 @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("minimum", &self.minimum)
            .field("maximum", &self.maximum)
            .field("default_value", &self.default_value)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecULong {
    pub parent_instance: GParamSpec,
    pub minimum: c_ulong,
    pub maximum: c_ulong,
    pub default_value: c_ulong,
}

impl ::std::fmt::Debug for GParamSpecULong {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecULong @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("minimum", &self.minimum)
            .field("maximum", &self.maximum)
            .field("default_value", &self.default_value)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecUnichar {
    pub parent_instance: GParamSpec,
    pub default_value: u32,
}

impl ::std::fmt::Debug for GParamSpecUnichar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecUnichar @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("default_value", &self.default_value)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecValueArray {
    pub parent_instance: GParamSpec,
    pub element_spec: *mut GParamSpec,
    pub fixed_n_elements: c_uint,
}

impl ::std::fmt::Debug for GParamSpecValueArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecValueArray @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("element_spec", &self.element_spec)
            .field("fixed_n_elements", &self.fixed_n_elements)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GParamSpecVariant {
    pub parent_instance: GParamSpec,
    pub type_: *mut glib::GVariantType,
    pub default_value: *mut glib::GVariant,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for GParamSpecVariant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GParamSpecVariant @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("type_", &self.type_)
            .field("default_value", &self.default_value)
            .finish()
    }
}

#[repr(C)]
pub struct GSignalGroup {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GSignalGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GSignalGroup @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GTypeModule {
    pub parent_instance: GObject,
    pub use_count: c_uint,
    pub type_infos: *mut glib::GSList,
    pub interface_infos: *mut glib::GSList,
    pub name: *mut c_char,
}

impl ::std::fmt::Debug for GTypeModule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GTypeModule @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("use_count", &self.use_count)
            .field("type_infos", &self.type_infos)
            .field("interface_infos", &self.interface_infos)
            .field("name", &self.name)
            .finish()
    }
}

// Interfaces
#[repr(C)]
pub struct GTypePlugin {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GTypePlugin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GTypePlugin @ {self:p}")
    }
}

#[link(name = "gobject-2.0")]
extern "C" {

    //=========================================================================
    // GBindingFlags
    //=========================================================================
    pub fn g_binding_flags_get_type() -> GType;

    //=========================================================================
    // GIOCondition
    //=========================================================================
    pub fn g_io_condition_get_type() -> GType;

    //=========================================================================
    // GCClosure
    //=========================================================================
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXED(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_BOOLEAN__FLAGS(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_BOOLEAN__FLAGSv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_STRING__OBJECT_POINTERv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__BOOLEAN(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_VOID__BOOLEANv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__BOXED(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_VOID__BOXEDv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__CHAR(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_VOID__CHARv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__DOUBLE(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_VOID__DOUBLEv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__ENUM(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_VOID__ENUMv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__FLAGS(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_VOID__FLAGSv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__FLOAT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_VOID__FLOATv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__INT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_VOID__INTv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__LONG(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_VOID__LONGv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__OBJECT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_VOID__OBJECTv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__PARAM(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_VOID__PARAMv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_VOID__POINTERv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__STRING(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_VOID__STRINGv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__UCHAR(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_VOID__UCHARv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__UINT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    pub fn g_cclosure_marshal_VOID__UINT_POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_VOID__UINT_POINTERv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    //pub fn g_cclosure_marshal_VOID__UINTv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__ULONG(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_VOID__ULONGv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__VARIANT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_VOID__VARIANTv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__VOID(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_VOID__VOIDv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_generic(
        closure: *mut GClosure,
        return_gvalue: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
    //pub fn g_cclosure_marshal_generic_va(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args_list: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_new(
        callback_func: GCallback,
        user_data: gpointer,
        destroy_data: GClosureNotify,
    ) -> *mut GClosure;
    pub fn g_cclosure_new_object(callback_func: GCallback, object: *mut GObject) -> *mut GClosure;
    pub fn g_cclosure_new_object_swap(
        callback_func: GCallback,
        object: *mut GObject,
    ) -> *mut GClosure;
    pub fn g_cclosure_new_swap(
        callback_func: GCallback,
        user_data: gpointer,
        destroy_data: GClosureNotify,
    ) -> *mut GClosure;

    //=========================================================================
    // GClosure
    //=========================================================================
    pub fn g_closure_get_type() -> GType;
    pub fn g_closure_new_object(sizeof_closure: c_uint, object: *mut GObject) -> *mut GClosure;
    pub fn g_closure_new_simple(sizeof_closure: c_uint, data: gpointer) -> *mut GClosure;
    pub fn g_closure_add_finalize_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
    pub fn g_closure_add_invalidate_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
    pub fn g_closure_add_marshal_guards(
        closure: *mut GClosure,
        pre_marshal_data: gpointer,
        pre_marshal_notify: GClosureNotify,
        post_marshal_data: gpointer,
        post_marshal_notify: GClosureNotify,
    );
    pub fn g_closure_invalidate(closure: *mut GClosure);
    pub fn g_closure_invoke(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: c_uint,
        param_values: *const GValue,
        invocation_hint: gpointer,
    );
    pub fn g_closure_ref(closure: *mut GClosure) -> *mut GClosure;
    pub fn g_closure_remove_finalize_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
    pub fn g_closure_remove_invalidate_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
    pub fn g_closure_set_marshal(closure: *mut GClosure, marshal: GClosureMarshal);
    pub fn g_closure_set_meta_marshal(
        closure: *mut GClosure,
        marshal_data: gpointer,
        meta_marshal: GClosureMarshal,
    );
    pub fn g_closure_sink(closure: *mut GClosure);
    pub fn g_closure_unref(closure: *mut GClosure);

    //=========================================================================
    // GObjectClass
    //=========================================================================
    pub fn g_object_class_find_property(
        oclass: *mut GObjectClass,
        property_name: *const c_char,
    ) -> *mut GParamSpec;
    pub fn g_object_class_install_properties(
        oclass: *mut GObjectClass,
        n_pspecs: c_uint,
        pspecs: *mut *mut GParamSpec,
    );
    pub fn g_object_class_install_property(
        oclass: *mut GObjectClass,
        property_id: c_uint,
        pspec: *mut GParamSpec,
    );
    pub fn g_object_class_list_properties(
        oclass: *mut GObjectClass,
        n_properties: *mut c_uint,
    ) -> *mut *mut GParamSpec;
    pub fn g_object_class_override_property(
        oclass: *mut GObjectClass,
        property_id: c_uint,
        name: *const c_char,
    );

    //=========================================================================
    // GParamSpecPool
    //=========================================================================
    #[cfg(feature = "v2_80")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_80")))]
    pub fn g_param_spec_pool_free(pool: *mut GParamSpecPool);
    pub fn g_param_spec_pool_insert(
        pool: *mut GParamSpecPool,
        pspec: *mut GParamSpec,
        owner_type: GType,
    );
    pub fn g_param_spec_pool_list(
        pool: *mut GParamSpecPool,
        owner_type: GType,
        n_pspecs_p: *mut c_uint,
    ) -> *mut *mut GParamSpec;
    pub fn g_param_spec_pool_list_owned(
        pool: *mut GParamSpecPool,
        owner_type: GType,
    ) -> *mut glib::GList;
    pub fn g_param_spec_pool_lookup(
        pool: *mut GParamSpecPool,
        param_name: *const c_char,
        owner_type: GType,
        walk_ancestors: gboolean,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_pool_remove(pool: *mut GParamSpecPool, pspec: *mut GParamSpec);
    pub fn g_param_spec_pool_new(type_prefixing: gboolean) -> *mut GParamSpecPool;

    //=========================================================================
    // GTypeClass
    //=========================================================================
    pub fn g_type_class_add_private(g_class: gpointer, private_size: size_t);
    pub fn g_type_class_get_instance_private_offset(g_class: gpointer) -> c_int;
    pub fn g_type_class_get_private(klass: *mut GTypeClass, private_type: GType) -> gpointer;
    pub fn g_type_class_peek_parent(g_class: gpointer) -> gpointer;
    pub fn g_type_class_unref(g_class: gpointer);
    pub fn g_type_class_unref_uncached(g_class: gpointer);
    pub fn g_type_class_adjust_private_offset(
        g_class: gpointer,
        private_size_or_offset: *mut c_int,
    );
    pub fn g_type_class_peek(type_: GType) -> gpointer;
    pub fn g_type_class_peek_static(type_: GType) -> gpointer;
    pub fn g_type_class_ref(type_: GType) -> gpointer;

    //=========================================================================
    // GTypeInstance
    //=========================================================================
    pub fn g_type_instance_get_private(
        instance: *mut GTypeInstance,
        private_type: GType,
    ) -> gpointer;

    //=========================================================================
    // GTypeInterface
    //=========================================================================
    pub fn g_type_interface_peek_parent(g_iface: gpointer) -> gpointer;
    pub fn g_type_interface_add_prerequisite(interface_type: GType, prerequisite_type: GType);
    pub fn g_type_interface_get_plugin(
        instance_type: GType,
        interface_type: GType,
    ) -> *mut GTypePlugin;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_type_interface_instantiatable_prerequisite(interface_type: GType) -> GType;
    pub fn g_type_interface_peek(instance_class: gpointer, iface_type: GType) -> gpointer;
    pub fn g_type_interface_prerequisites(
        interface_type: GType,
        n_prerequisites: *mut c_uint,
    ) -> *mut GType;

    //=========================================================================
    // GTypeValueTable
    //=========================================================================
    pub fn g_type_value_table_peek(type_: GType) -> *mut GTypeValueTable;

    //=========================================================================
    // GValue
    //=========================================================================
    pub fn g_value_get_type() -> GType;
    pub fn g_value_copy(src_value: *const GValue, dest_value: *mut GValue);
    pub fn g_value_dup_boxed(value: *const GValue) -> gpointer;
    pub fn g_value_dup_object(value: *const GValue) -> *mut GObject;
    pub fn g_value_dup_param(value: *const GValue) -> *mut GParamSpec;
    pub fn g_value_dup_string(value: *const GValue) -> *mut c_char;
    pub fn g_value_dup_variant(value: *const GValue) -> *mut glib::GVariant;
    pub fn g_value_fits_pointer(value: *const GValue) -> gboolean;
    pub fn g_value_get_boolean(value: *const GValue) -> gboolean;
    pub fn g_value_get_boxed(value: *const GValue) -> gpointer;
    pub fn g_value_get_char(value: *const GValue) -> c_char;
    pub fn g_value_get_double(value: *const GValue) -> c_double;
    pub fn g_value_get_enum(value: *const GValue) -> c_int;
    pub fn g_value_get_flags(value: *const GValue) -> c_uint;
    pub fn g_value_get_float(value: *const GValue) -> c_float;
    pub fn g_value_get_gtype(value: *const GValue) -> GType;
    pub fn g_value_get_int(value: *const GValue) -> c_int;
    pub fn g_value_get_int64(value: *const GValue) -> i64;
    pub fn g_value_get_long(value: *const GValue) -> c_long;
    pub fn g_value_get_object(value: *const GValue) -> *mut GObject;
    pub fn g_value_get_param(value: *const GValue) -> *mut GParamSpec;
    pub fn g_value_get_pointer(value: *const GValue) -> gpointer;
    pub fn g_value_get_schar(value: *const GValue) -> i8;
    pub fn g_value_get_string(value: *const GValue) -> *const c_char;
    pub fn g_value_get_uchar(value: *const GValue) -> c_uchar;
    pub fn g_value_get_uint(value: *const GValue) -> c_uint;
    pub fn g_value_get_uint64(value: *const GValue) -> u64;
    pub fn g_value_get_ulong(value: *const GValue) -> c_ulong;
    pub fn g_value_get_variant(value: *const GValue) -> *mut glib::GVariant;
    pub fn g_value_init(value: *mut GValue, g_type: GType) -> *mut GValue;
    pub fn g_value_init_from_instance(value: *mut GValue, instance: gpointer);
    pub fn g_value_peek_pointer(value: *const GValue) -> gpointer;
    pub fn g_value_reset(value: *mut GValue) -> *mut GValue;
    pub fn g_value_set_boolean(value: *mut GValue, v_boolean: gboolean);
    pub fn g_value_set_boxed(value: *mut GValue, v_boxed: gconstpointer);
    pub fn g_value_set_boxed_take_ownership(value: *mut GValue, v_boxed: gconstpointer);
    pub fn g_value_set_char(value: *mut GValue, v_char: c_char);
    pub fn g_value_set_double(value: *mut GValue, v_double: c_double);
    pub fn g_value_set_enum(value: *mut GValue, v_enum: c_int);
    pub fn g_value_set_flags(value: *mut GValue, v_flags: c_uint);
    pub fn g_value_set_float(value: *mut GValue, v_float: c_float);
    pub fn g_value_set_gtype(value: *mut GValue, v_gtype: GType);
    pub fn g_value_set_instance(value: *mut GValue, instance: gpointer);
    pub fn g_value_set_int(value: *mut GValue, v_int: c_int);
    pub fn g_value_set_int64(value: *mut GValue, v_int64: i64);
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_value_set_interned_string(value: *mut GValue, v_string: *const c_char);
    pub fn g_value_set_long(value: *mut GValue, v_long: c_long);
    pub fn g_value_set_object(value: *mut GValue, v_object: *mut GObject);
    pub fn g_value_set_object_take_ownership(value: *mut GValue, v_object: gpointer);
    pub fn g_value_set_param(value: *mut GValue, param: *mut GParamSpec);
    pub fn g_value_set_param_take_ownership(value: *mut GValue, param: *mut GParamSpec);
    pub fn g_value_set_pointer(value: *mut GValue, v_pointer: gpointer);
    pub fn g_value_set_schar(value: *mut GValue, v_char: i8);
    pub fn g_value_set_static_boxed(value: *mut GValue, v_boxed: gconstpointer);
    pub fn g_value_set_static_string(value: *mut GValue, v_string: *const c_char);
    pub fn g_value_set_string(value: *mut GValue, v_string: *const c_char);
    pub fn g_value_set_string_take_ownership(value: *mut GValue, v_string: *mut c_char);
    pub fn g_value_set_uchar(value: *mut GValue, v_uchar: c_uchar);
    pub fn g_value_set_uint(value: *mut GValue, v_uint: c_uint);
    pub fn g_value_set_uint64(value: *mut GValue, v_uint64: u64);
    pub fn g_value_set_ulong(value: *mut GValue, v_ulong: c_ulong);
    pub fn g_value_set_variant(value: *mut GValue, variant: *mut glib::GVariant);
    #[cfg(feature = "v2_80")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_80")))]
    pub fn g_value_steal_string(value: *mut GValue) -> *mut c_char;
    pub fn g_value_take_boxed(value: *mut GValue, v_boxed: gconstpointer);
    pub fn g_value_take_object(value: *mut GValue, v_object: gpointer);
    pub fn g_value_take_param(value: *mut GValue, param: *mut GParamSpec);
    pub fn g_value_take_string(value: *mut GValue, v_string: *mut c_char);
    pub fn g_value_take_variant(value: *mut GValue, variant: *mut glib::GVariant);
    pub fn g_value_transform(src_value: *const GValue, dest_value: *mut GValue) -> gboolean;
    pub fn g_value_unset(value: *mut GValue);
    pub fn g_value_register_transform_func(
        src_type: GType,
        dest_type: GType,
        transform_func: GValueTransform,
    );
    pub fn g_value_type_compatible(src_type: GType, dest_type: GType) -> gboolean;
    pub fn g_value_type_transformable(src_type: GType, dest_type: GType) -> gboolean;

    //=========================================================================
    // GValueArray
    //=========================================================================
    pub fn g_value_array_get_type() -> GType;
    pub fn g_value_array_new(n_prealloced: c_uint) -> *mut GValueArray;
    pub fn g_value_array_append(
        value_array: *mut GValueArray,
        value: *const GValue,
    ) -> *mut GValueArray;
    pub fn g_value_array_copy(value_array: *const GValueArray) -> *mut GValueArray;
    pub fn g_value_array_free(value_array: *mut GValueArray);
    pub fn g_value_array_get_nth(value_array: *mut GValueArray, index_: c_uint) -> *mut GValue;
    pub fn g_value_array_insert(
        value_array: *mut GValueArray,
        index_: c_uint,
        value: *const GValue,
    ) -> *mut GValueArray;
    pub fn g_value_array_prepend(
        value_array: *mut GValueArray,
        value: *const GValue,
    ) -> *mut GValueArray;
    pub fn g_value_array_remove(value_array: *mut GValueArray, index_: c_uint) -> *mut GValueArray;
    pub fn g_value_array_sort(
        value_array: *mut GValueArray,
        compare_func: glib::GCompareFunc,
    ) -> *mut GValueArray;
    pub fn g_value_array_sort_with_data(
        value_array: *mut GValueArray,
        compare_func: glib::GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GValueArray;

    //=========================================================================
    // GWeakRef
    //=========================================================================
    pub fn g_weak_ref_clear(weak_ref: *mut GWeakRef);
    pub fn g_weak_ref_get(weak_ref: *mut GWeakRef) -> *mut GObject;
    pub fn g_weak_ref_init(weak_ref: *mut GWeakRef, object: *mut GObject);
    pub fn g_weak_ref_set(weak_ref: *mut GWeakRef, object: *mut GObject);

    //=========================================================================
    // GBinding
    //=========================================================================
    pub fn g_binding_get_type() -> GType;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_binding_dup_source(binding: *mut GBinding) -> *mut GObject;
    #[cfg(feature = "v2_68")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_68")))]
    pub fn g_binding_dup_target(binding: *mut GBinding) -> *mut GObject;
    pub fn g_binding_get_flags(binding: *mut GBinding) -> GBindingFlags;
    pub fn g_binding_get_source(binding: *mut GBinding) -> *mut GObject;
    pub fn g_binding_get_source_property(binding: *mut GBinding) -> *const c_char;
    pub fn g_binding_get_target(binding: *mut GBinding) -> *mut GObject;
    pub fn g_binding_get_target_property(binding: *mut GBinding) -> *const c_char;
    pub fn g_binding_unbind(binding: *mut GBinding);

    //=========================================================================
    // GBindingGroup
    //=========================================================================
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_binding_group_get_type() -> GType;
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_binding_group_new() -> *mut GBindingGroup;
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_binding_group_bind(
        self_: *mut GBindingGroup,
        source_property: *const c_char,
        target: *mut GObject,
        target_property: *const c_char,
        flags: GBindingFlags,
    );
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_binding_group_bind_full(
        self_: *mut GBindingGroup,
        source_property: *const c_char,
        target: *mut GObject,
        target_property: *const c_char,
        flags: GBindingFlags,
        transform_to: GBindingTransformFunc,
        transform_from: GBindingTransformFunc,
        user_data: gpointer,
        user_data_destroy: glib::GDestroyNotify,
    );
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_binding_group_bind_with_closures(
        self_: *mut GBindingGroup,
        source_property: *const c_char,
        target: *mut GObject,
        target_property: *const c_char,
        flags: GBindingFlags,
        transform_to: *mut GClosure,
        transform_from: *mut GClosure,
    );
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_binding_group_dup_source(self_: *mut GBindingGroup) -> *mut GObject;
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_binding_group_set_source(self_: *mut GBindingGroup, source: *mut GObject);

    //=========================================================================
    // GInitiallyUnowned
    //=========================================================================
    pub fn g_initially_unowned_get_type() -> GType;

    //=========================================================================
    // GObject
    //=========================================================================
    pub fn g_object_get_type() -> GType;
    pub fn g_object_new(
        object_type: GType,
        first_property_name: *const c_char,
        ...
    ) -> *mut GObject;
    //pub fn g_object_new_valist(object_type: GType, first_property_name: *const c_char, var_args: /*Unimplemented*/va_list) -> *mut GObject;
    pub fn g_object_new_with_properties(
        object_type: GType,
        n_properties: c_uint,
        names: *mut *const c_char,
        values: *const GValue,
    ) -> *mut GObject;
    pub fn g_object_newv(
        object_type: GType,
        n_parameters: c_uint,
        parameters: *mut GParameter,
    ) -> *mut GObject;
    pub fn g_object_compat_control(what: size_t, data: gpointer) -> size_t;
    pub fn g_object_interface_find_property(
        g_iface: gpointer,
        property_name: *const c_char,
    ) -> *mut GParamSpec;
    pub fn g_object_interface_install_property(g_iface: gpointer, pspec: *mut GParamSpec);
    pub fn g_object_interface_list_properties(
        g_iface: gpointer,
        n_properties_p: *mut c_uint,
    ) -> *mut *mut GParamSpec;
    pub fn g_object_add_toggle_ref(object: *mut GObject, notify: GToggleNotify, data: gpointer);
    pub fn g_object_add_weak_pointer(object: *mut GObject, weak_pointer_location: *mut gpointer);
    pub fn g_object_bind_property(
        source: *mut GObject,
        source_property: *const c_char,
        target: *mut GObject,
        target_property: *const c_char,
        flags: GBindingFlags,
    ) -> *mut GBinding;
    pub fn g_object_bind_property_full(
        source: *mut GObject,
        source_property: *const c_char,
        target: *mut GObject,
        target_property: *const c_char,
        flags: GBindingFlags,
        transform_to: GBindingTransformFunc,
        transform_from: GBindingTransformFunc,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    ) -> *mut GBinding;
    pub fn g_object_bind_property_with_closures(
        source: *mut GObject,
        source_property: *const c_char,
        target: *mut GObject,
        target_property: *const c_char,
        flags: GBindingFlags,
        transform_to: *mut GClosure,
        transform_from: *mut GClosure,
    ) -> *mut GBinding;
    pub fn g_object_connect(object: *mut GObject, signal_spec: *const c_char, ...) -> *mut GObject;
    pub fn g_object_disconnect(object: *mut GObject, signal_spec: *const c_char, ...);
    pub fn g_object_dup_data(
        object: *mut GObject,
        key: *const c_char,
        dup_func: glib::GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
    pub fn g_object_dup_qdata(
        object: *mut GObject,
        quark: glib::GQuark,
        dup_func: glib::GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
    pub fn g_object_force_floating(object: *mut GObject);
    pub fn g_object_freeze_notify(object: *mut GObject);
    pub fn g_object_get(object: *mut GObject, first_property_name: *const c_char, ...);
    pub fn g_object_get_data(object: *mut GObject, key: *const c_char) -> gpointer;
    pub fn g_object_get_property(
        object: *mut GObject,
        property_name: *const c_char,
        value: *mut GValue,
    );
    pub fn g_object_get_qdata(object: *mut GObject, quark: glib::GQuark) -> gpointer;
    //pub fn g_object_get_valist(object: *mut GObject, first_property_name: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn g_object_getv(
        object: *mut GObject,
        n_properties: c_uint,
        names: *mut *const c_char,
        values: *mut GValue,
    );
    pub fn g_object_is_floating(object: *mut GObject) -> gboolean;
    pub fn g_object_notify(object: *mut GObject, property_name: *const c_char);
    pub fn g_object_notify_by_pspec(object: *mut GObject, pspec: *mut GParamSpec);
    pub fn g_object_ref(object: *mut GObject) -> *mut GObject;
    pub fn g_object_ref_sink(object: *mut GObject) -> *mut GObject;
    pub fn g_object_remove_toggle_ref(object: *mut GObject, notify: GToggleNotify, data: gpointer);
    pub fn g_object_remove_weak_pointer(object: *mut GObject, weak_pointer_location: *mut gpointer);
    pub fn g_object_replace_data(
        object: *mut GObject,
        key: *const c_char,
        oldval: gpointer,
        newval: gpointer,
        destroy: glib::GDestroyNotify,
        old_destroy: *mut glib::GDestroyNotify,
    ) -> gboolean;
    pub fn g_object_replace_qdata(
        object: *mut GObject,
        quark: glib::GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: glib::GDestroyNotify,
        old_destroy: *mut glib::GDestroyNotify,
    ) -> gboolean;
    pub fn g_object_run_dispose(object: *mut GObject);
    pub fn g_object_set(object: *mut GObject, first_property_name: *const c_char, ...);
    pub fn g_object_set_data(object: *mut GObject, key: *const c_char, data: gpointer);
    pub fn g_object_set_data_full(
        object: *mut GObject,
        key: *const c_char,
        data: gpointer,
        destroy: glib::GDestroyNotify,
    );
    pub fn g_object_set_property(
        object: *mut GObject,
        property_name: *const c_char,
        value: *const GValue,
    );
    pub fn g_object_set_qdata(object: *mut GObject, quark: glib::GQuark, data: gpointer);
    pub fn g_object_set_qdata_full(
        object: *mut GObject,
        quark: glib::GQuark,
        data: gpointer,
        destroy: glib::GDestroyNotify,
    );
    //pub fn g_object_set_valist(object: *mut GObject, first_property_name: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn g_object_setv(
        object: *mut GObject,
        n_properties: c_uint,
        names: *mut *const c_char,
        values: *const GValue,
    );
    pub fn g_object_steal_data(object: *mut GObject, key: *const c_char) -> gpointer;
    pub fn g_object_steal_qdata(object: *mut GObject, quark: glib::GQuark) -> gpointer;
    #[cfg(feature = "v2_70")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_70")))]
    pub fn g_object_take_ref(object: *mut GObject) -> *mut GObject;
    pub fn g_object_thaw_notify(object: *mut GObject);
    pub fn g_object_unref(object: *mut GObject);
    pub fn g_object_watch_closure(object: *mut GObject, closure: *mut GClosure);
    pub fn g_object_weak_ref(object: *mut GObject, notify: GWeakNotify, data: gpointer);
    pub fn g_object_weak_unref(object: *mut GObject, notify: GWeakNotify, data: gpointer);

    //=========================================================================
    // GParamSpec
    //=========================================================================
    pub fn g_param_spec_internal(
        param_type: GType,
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_param_spec_is_valid_name(name: *const c_char) -> gboolean;
    pub fn g_param_spec_get_blurb(pspec: *mut GParamSpec) -> *const c_char;
    pub fn g_param_spec_get_default_value(pspec: *mut GParamSpec) -> *const GValue;
    pub fn g_param_spec_get_name(pspec: *mut GParamSpec) -> *const c_char;
    pub fn g_param_spec_get_name_quark(pspec: *mut GParamSpec) -> glib::GQuark;
    pub fn g_param_spec_get_nick(pspec: *mut GParamSpec) -> *const c_char;
    pub fn g_param_spec_get_qdata(pspec: *mut GParamSpec, quark: glib::GQuark) -> gpointer;
    pub fn g_param_spec_get_redirect_target(pspec: *mut GParamSpec) -> *mut GParamSpec;
    pub fn g_param_spec_ref(pspec: *mut GParamSpec) -> *mut GParamSpec;
    pub fn g_param_spec_ref_sink(pspec: *mut GParamSpec) -> *mut GParamSpec;
    pub fn g_param_spec_set_qdata(pspec: *mut GParamSpec, quark: glib::GQuark, data: gpointer);
    pub fn g_param_spec_set_qdata_full(
        pspec: *mut GParamSpec,
        quark: glib::GQuark,
        data: gpointer,
        destroy: glib::GDestroyNotify,
    );
    pub fn g_param_spec_sink(pspec: *mut GParamSpec);
    pub fn g_param_spec_steal_qdata(pspec: *mut GParamSpec, quark: glib::GQuark) -> gpointer;
    pub fn g_param_spec_unref(pspec: *mut GParamSpec);

    //=========================================================================
    // GSignalGroup
    //=========================================================================
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_signal_group_get_type() -> GType;
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_signal_group_new(target_type: GType) -> *mut GSignalGroup;
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_signal_group_block(self_: *mut GSignalGroup);
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_signal_group_connect(
        self_: *mut GSignalGroup,
        detailed_signal: *const c_char,
        c_handler: GCallback,
        data: gpointer,
    );
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_signal_group_connect_after(
        self_: *mut GSignalGroup,
        detailed_signal: *const c_char,
        c_handler: GCallback,
        data: gpointer,
    );
    #[cfg(feature = "v2_74")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_74")))]
    pub fn g_signal_group_connect_closure(
        self_: *mut GSignalGroup,
        detailed_signal: *const c_char,
        closure: *mut GClosure,
        after: gboolean,
    );
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_signal_group_connect_data(
        self_: *mut GSignalGroup,
        detailed_signal: *const c_char,
        c_handler: GCallback,
        data: gpointer,
        notify: GClosureNotify,
        flags: GConnectFlags,
    );
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_signal_group_connect_object(
        self_: *mut GSignalGroup,
        detailed_signal: *const c_char,
        c_handler: GCallback,
        object: gpointer,
        flags: GConnectFlags,
    );
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_signal_group_connect_swapped(
        self_: *mut GSignalGroup,
        detailed_signal: *const c_char,
        c_handler: GCallback,
        data: gpointer,
    );
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_signal_group_dup_target(self_: *mut GSignalGroup) -> *mut GObject;
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_signal_group_set_target(self_: *mut GSignalGroup, target: *mut GObject);
    #[cfg(feature = "v2_72")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_72")))]
    pub fn g_signal_group_unblock(self_: *mut GSignalGroup);

    //=========================================================================
    // GTypeModule
    //=========================================================================
    pub fn g_type_module_get_type() -> GType;
    pub fn g_type_module_add_interface(
        module: *mut GTypeModule,
        instance_type: GType,
        interface_type: GType,
        interface_info: *const GInterfaceInfo,
    );
    pub fn g_type_module_register_enum(
        module: *mut GTypeModule,
        name: *const c_char,
        const_static_values: *const GEnumValue,
    ) -> GType;
    pub fn g_type_module_register_flags(
        module: *mut GTypeModule,
        name: *const c_char,
        const_static_values: *const GFlagsValue,
    ) -> GType;
    pub fn g_type_module_register_type(
        module: *mut GTypeModule,
        parent_type: GType,
        type_name: *const c_char,
        type_info: *const GTypeInfo,
        flags: GTypeFlags,
    ) -> GType;
    pub fn g_type_module_set_name(module: *mut GTypeModule, name: *const c_char);
    pub fn g_type_module_unuse(module: *mut GTypeModule);
    pub fn g_type_module_use(module: *mut GTypeModule) -> gboolean;

    //=========================================================================
    // GTypePlugin
    //=========================================================================
    pub fn g_type_plugin_get_type() -> GType;
    pub fn g_type_plugin_complete_interface_info(
        plugin: *mut GTypePlugin,
        instance_type: GType,
        interface_type: GType,
        info: *mut GInterfaceInfo,
    );
    pub fn g_type_plugin_complete_type_info(
        plugin: *mut GTypePlugin,
        g_type: GType,
        info: *mut GTypeInfo,
        value_table: *mut GTypeValueTable,
    );
    pub fn g_type_plugin_unuse(plugin: *mut GTypePlugin);
    pub fn g_type_plugin_use(plugin: *mut GTypePlugin);

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn g_boxed_copy(boxed_type: GType, src_boxed: gconstpointer) -> gpointer;
    pub fn g_boxed_free(boxed_type: GType, boxed: gpointer);
    pub fn g_boxed_type_register_static(
        name: *const c_char,
        boxed_copy: GBoxedCopyFunc,
        boxed_free: GBoxedFreeFunc,
    ) -> GType;
    pub fn g_clear_object(object_ptr: *mut *mut GObject);
    #[cfg(feature = "v2_62")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_62")))]
    pub fn g_clear_signal_handler(handler_id_ptr: *mut c_ulong, instance: *mut GObject);
    pub fn g_enum_complete_type_info(
        g_enum_type: GType,
        info: *mut GTypeInfo,
        const_values: *const GEnumValue,
    );
    pub fn g_enum_get_value(enum_class: *mut GEnumClass, value: c_int) -> *mut GEnumValue;
    pub fn g_enum_get_value_by_name(
        enum_class: *mut GEnumClass,
        name: *const c_char,
    ) -> *mut GEnumValue;
    pub fn g_enum_get_value_by_nick(
        enum_class: *mut GEnumClass,
        nick: *const c_char,
    ) -> *mut GEnumValue;
    pub fn g_enum_register_static(
        name: *const c_char,
        const_static_values: *const GEnumValue,
    ) -> GType;
    pub fn g_enum_to_string(g_enum_type: GType, value: c_int) -> *mut c_char;
    pub fn g_flags_complete_type_info(
        g_flags_type: GType,
        info: *mut GTypeInfo,
        const_values: *const GFlagsValue,
    );
    pub fn g_flags_get_first_value(
        flags_class: *mut GFlagsClass,
        value: c_uint,
    ) -> *mut GFlagsValue;
    pub fn g_flags_get_value_by_name(
        flags_class: *mut GFlagsClass,
        name: *const c_char,
    ) -> *mut GFlagsValue;
    pub fn g_flags_get_value_by_nick(
        flags_class: *mut GFlagsClass,
        nick: *const c_char,
    ) -> *mut GFlagsValue;
    pub fn g_flags_register_static(
        name: *const c_char,
        const_static_values: *const GFlagsValue,
    ) -> GType;
    pub fn g_flags_to_string(flags_type: GType, value: c_uint) -> *mut c_char;
    pub fn g_gtype_get_type() -> GType;
    pub fn g_param_spec_boolean(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        default_value: gboolean,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_boxed(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        boxed_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_char(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        minimum: i8,
        maximum: i8,
        default_value: i8,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_double(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        minimum: c_double,
        maximum: c_double,
        default_value: c_double,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_enum(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        enum_type: GType,
        default_value: c_int,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_flags(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        flags_type: GType,
        default_value: c_uint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_float(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        minimum: c_float,
        maximum: c_float,
        default_value: c_float,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_gtype(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        is_a_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_int(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        minimum: c_int,
        maximum: c_int,
        default_value: c_int,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_int64(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        minimum: i64,
        maximum: i64,
        default_value: i64,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_long(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        minimum: c_long,
        maximum: c_long,
        default_value: c_long,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_object(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        object_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_override(
        name: *const c_char,
        overridden: *mut GParamSpec,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_param(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        param_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_pointer(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_string(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        default_value: *const c_char,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_uchar(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        minimum: u8,
        maximum: u8,
        default_value: u8,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_uint(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        minimum: c_uint,
        maximum: c_uint,
        default_value: c_uint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_uint64(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        minimum: u64,
        maximum: u64,
        default_value: u64,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_ulong(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        minimum: c_ulong,
        maximum: c_ulong,
        default_value: c_ulong,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_unichar(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        default_value: u32,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_value_array(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        element_spec: *mut GParamSpec,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_spec_variant(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        type_: *const glib::GVariantType,
        default_value: *mut glib::GVariant,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
    pub fn g_param_type_register_static(
        name: *const c_char,
        pspec_info: *const GParamSpecTypeInfo,
    ) -> GType;
    pub fn g_param_value_convert(
        pspec: *mut GParamSpec,
        src_value: *const GValue,
        dest_value: *mut GValue,
        strict_validation: gboolean,
    ) -> gboolean;
    pub fn g_param_value_defaults(pspec: *mut GParamSpec, value: *const GValue) -> gboolean;
    #[cfg(feature = "v2_74")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_74")))]
    pub fn g_param_value_is_valid(pspec: *mut GParamSpec, value: *const GValue) -> gboolean;
    pub fn g_param_value_set_default(pspec: *mut GParamSpec, value: *mut GValue);
    pub fn g_param_value_validate(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean;
    pub fn g_param_values_cmp(
        pspec: *mut GParamSpec,
        value1: *const GValue,
        value2: *const GValue,
    ) -> c_int;
    pub fn g_pointer_type_register_static(name: *const c_char) -> GType;
    pub fn g_signal_accumulator_first_wins(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        dummy: gpointer,
    ) -> gboolean;
    pub fn g_signal_accumulator_true_handled(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        dummy: gpointer,
    ) -> gboolean;
    pub fn g_signal_add_emission_hook(
        signal_id: c_uint,
        detail: glib::GQuark,
        hook_func: GSignalEmissionHook,
        hook_data: gpointer,
        data_destroy: glib::GDestroyNotify,
    ) -> c_ulong;
    pub fn g_signal_chain_from_overridden(
        instance_and_params: *const GValue,
        return_value: *mut GValue,
    );
    pub fn g_signal_chain_from_overridden_handler(instance: gpointer, ...);
    pub fn g_signal_connect_closure(
        instance: *mut GObject,
        detailed_signal: *const c_char,
        closure: *mut GClosure,
        after: gboolean,
    ) -> c_ulong;
    pub fn g_signal_connect_closure_by_id(
        instance: *mut GObject,
        signal_id: c_uint,
        detail: glib::GQuark,
        closure: *mut GClosure,
        after: gboolean,
    ) -> c_ulong;
    pub fn g_signal_connect_data(
        instance: *mut GObject,
        detailed_signal: *const c_char,
        c_handler: GCallback,
        data: gpointer,
        destroy_data: GClosureNotify,
        connect_flags: GConnectFlags,
    ) -> c_ulong;
    pub fn g_signal_connect_object(
        instance: gpointer,
        detailed_signal: *const c_char,
        c_handler: GCallback,
        gobject: *mut GObject,
        connect_flags: GConnectFlags,
    ) -> c_ulong;
    pub fn g_signal_emit(instance: *mut GObject, signal_id: c_uint, detail: glib::GQuark, ...);
    pub fn g_signal_emit_by_name(instance: *mut GObject, detailed_signal: *const c_char, ...);
    //pub fn g_signal_emit_valist(instance: gpointer, signal_id: c_uint, detail: glib::GQuark, var_args: /*Unimplemented*/va_list);
    pub fn g_signal_emitv(
        instance_and_params: *const GValue,
        signal_id: c_uint,
        detail: glib::GQuark,
        return_value: *mut GValue,
    );
    pub fn g_signal_get_invocation_hint(instance: *mut GObject) -> *mut GSignalInvocationHint;
    pub fn g_signal_handler_block(instance: *mut GObject, handler_id: c_ulong);
    pub fn g_signal_handler_disconnect(instance: *mut GObject, handler_id: c_ulong);
    pub fn g_signal_handler_find(
        instance: *mut GObject,
        mask: GSignalMatchType,
        signal_id: c_uint,
        detail: glib::GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> c_ulong;
    pub fn g_signal_handler_is_connected(instance: *mut GObject, handler_id: c_ulong) -> gboolean;
    pub fn g_signal_handler_unblock(instance: *mut GObject, handler_id: c_ulong);
    pub fn g_signal_handlers_block_matched(
        instance: *mut GObject,
        mask: GSignalMatchType,
        signal_id: c_uint,
        detail: glib::GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> c_uint;
    pub fn g_signal_handlers_destroy(instance: *mut GObject);
    pub fn g_signal_handlers_disconnect_matched(
        instance: *mut GObject,
        mask: GSignalMatchType,
        signal_id: c_uint,
        detail: glib::GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> c_uint;
    pub fn g_signal_handlers_unblock_matched(
        instance: *mut GObject,
        mask: GSignalMatchType,
        signal_id: c_uint,
        detail: glib::GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> c_uint;
    pub fn g_signal_has_handler_pending(
        instance: *mut GObject,
        signal_id: c_uint,
        detail: glib::GQuark,
        may_be_blocked: gboolean,
    ) -> gboolean;
    #[cfg(feature = "v2_66")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_66")))]
    pub fn g_signal_is_valid_name(name: *const c_char) -> gboolean;
    pub fn g_signal_list_ids(itype: GType, n_ids: *mut c_uint) -> *mut c_uint;
    pub fn g_signal_lookup(name: *const c_char, itype: GType) -> c_uint;
    pub fn g_signal_name(signal_id: c_uint) -> *const c_char;
    pub fn g_signal_new(
        signal_name: *const c_char,
        itype: GType,
        signal_flags: GSignalFlags,
        class_offset: c_uint,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: c_uint,
        ...
    ) -> c_uint;
    pub fn g_signal_new_class_handler(
        signal_name: *const c_char,
        itype: GType,
        signal_flags: GSignalFlags,
        class_handler: GCallback,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: c_uint,
        ...
    ) -> c_uint;
    //pub fn g_signal_new_valist(signal_name: *const c_char, itype: GType, signal_flags: GSignalFlags, class_closure: *mut GClosure, accumulator: GSignalAccumulator, accu_data: gpointer, c_marshaller: GSignalCMarshaller, return_type: GType, n_params: c_uint, args: /*Unimplemented*/va_list) -> c_uint;
    pub fn g_signal_newv(
        signal_name: *const c_char,
        itype: GType,
        signal_flags: GSignalFlags,
        class_closure: *mut GClosure,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: c_uint,
        param_types: *mut GType,
    ) -> c_uint;
    pub fn g_signal_override_class_closure(
        signal_id: c_uint,
        instance_type: GType,
        class_closure: *mut GClosure,
    );
    pub fn g_signal_override_class_handler(
        signal_name: *const c_char,
        instance_type: GType,
        class_handler: GCallback,
    );
    pub fn g_signal_parse_name(
        detailed_signal: *const c_char,
        itype: GType,
        signal_id_p: *mut c_uint,
        detail_p: *mut glib::GQuark,
        force_detail_quark: gboolean,
    ) -> gboolean;
    pub fn g_signal_query(signal_id: c_uint, query: *mut GSignalQuery);
    pub fn g_signal_remove_emission_hook(signal_id: c_uint, hook_id: c_ulong);
    //pub fn g_signal_set_va_marshaller(signal_id: c_uint, instance_type: GType, va_marshaller: /*Ignored*/GSignalCVaMarshaller);
    pub fn g_signal_stop_emission(instance: *mut GObject, signal_id: c_uint, detail: glib::GQuark);
    pub fn g_signal_stop_emission_by_name(instance: *mut GObject, detailed_signal: *const c_char);
    pub fn g_signal_type_cclosure_new(itype: GType, struct_offset: c_uint) -> *mut GClosure;
    pub fn g_strdup_value_contents(value: *const GValue) -> *mut c_char;
    pub fn g_type_add_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc);
    pub fn g_type_add_class_private(class_type: GType, private_size: size_t);
    pub fn g_type_add_instance_private(class_type: GType, private_size: size_t) -> c_int;
    pub fn g_type_add_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc);
    pub fn g_type_add_interface_dynamic(
        instance_type: GType,
        interface_type: GType,
        plugin: *mut GTypePlugin,
    );
    pub fn g_type_add_interface_static(
        instance_type: GType,
        interface_type: GType,
        info: *const GInterfaceInfo,
    );
    pub fn g_type_check_class_cast(g_class: *mut GTypeClass, is_a_type: GType) -> *mut GTypeClass;
    pub fn g_type_check_class_is_a(g_class: *mut GTypeClass, is_a_type: GType) -> gboolean;
    pub fn g_type_check_instance(instance: *mut GTypeInstance) -> gboolean;
    pub fn g_type_check_instance_cast(
        instance: *mut GTypeInstance,
        iface_type: GType,
    ) -> *mut GTypeInstance;
    pub fn g_type_check_instance_is_a(instance: *mut GTypeInstance, iface_type: GType) -> gboolean;
    pub fn g_type_check_instance_is_fundamentally_a(
        instance: *mut GTypeInstance,
        fundamental_type: GType,
    ) -> gboolean;
    pub fn g_type_check_is_value_type(type_: GType) -> gboolean;
    pub fn g_type_check_value(value: *const GValue) -> gboolean;
    pub fn g_type_check_value_holds(value: *const GValue, type_: GType) -> gboolean;
    pub fn g_type_children(type_: GType, n_children: *mut c_uint) -> *mut GType;
    pub fn g_type_create_instance(type_: GType) -> *mut GTypeInstance;
    pub fn g_type_default_interface_peek(g_type: GType) -> gpointer;
    pub fn g_type_default_interface_ref(g_type: GType) -> gpointer;
    pub fn g_type_default_interface_unref(g_iface: gpointer);
    pub fn g_type_depth(type_: GType) -> c_uint;
    pub fn g_type_ensure(type_: GType);
    pub fn g_type_free_instance(instance: *mut GTypeInstance);
    pub fn g_type_from_name(name: *const c_char) -> GType;
    pub fn g_type_fundamental(type_id: GType) -> GType;
    pub fn g_type_fundamental_next() -> GType;
    pub fn g_type_get_instance_count(type_: GType) -> c_int;
    pub fn g_type_get_plugin(type_: GType) -> *mut GTypePlugin;
    pub fn g_type_get_qdata(type_: GType, quark: glib::GQuark) -> gpointer;
    pub fn g_type_get_type_registration_serial() -> c_uint;
    pub fn g_type_init();
    pub fn g_type_init_with_debug_flags(debug_flags: GTypeDebugFlags);
    pub fn g_type_interfaces(type_: GType, n_interfaces: *mut c_uint) -> *mut GType;
    pub fn g_type_is_a(type_: GType, is_a_type: GType) -> gboolean;
    pub fn g_type_name(type_: GType) -> *const c_char;
    pub fn g_type_name_from_class(g_class: *mut GTypeClass) -> *const c_char;
    pub fn g_type_name_from_instance(instance: *mut GTypeInstance) -> *const c_char;
    pub fn g_type_next_base(leaf_type: GType, root_type: GType) -> GType;
    pub fn g_type_parent(type_: GType) -> GType;
    pub fn g_type_qname(type_: GType) -> glib::GQuark;
    pub fn g_type_query(type_: GType, query: *mut GTypeQuery);
    pub fn g_type_register_dynamic(
        parent_type: GType,
        type_name: *const c_char,
        plugin: *mut GTypePlugin,
        flags: GTypeFlags,
    ) -> GType;
    pub fn g_type_register_fundamental(
        type_id: GType,
        type_name: *const c_char,
        info: *const GTypeInfo,
        finfo: *const GTypeFundamentalInfo,
        flags: GTypeFlags,
    ) -> GType;
    pub fn g_type_register_static(
        parent_type: GType,
        type_name: *const c_char,
        info: *const GTypeInfo,
        flags: GTypeFlags,
    ) -> GType;
    pub fn g_type_register_static_simple(
        parent_type: GType,
        type_name: *const c_char,
        class_size: c_uint,
        class_init: GClassInitFunc,
        instance_size: c_uint,
        instance_init: GInstanceInitFunc,
        flags: GTypeFlags,
    ) -> GType;
    pub fn g_type_remove_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc);
    pub fn g_type_remove_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc);
    pub fn g_type_set_qdata(type_: GType, quark: glib::GQuark, data: gpointer);
    pub fn g_type_test_flags(type_: GType, flags: c_uint) -> gboolean;
    pub fn g_variant_get_gtype() -> GType;

}
